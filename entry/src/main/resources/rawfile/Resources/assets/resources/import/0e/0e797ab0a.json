[1,["d67a02b0-ffdc-44e2-bf72-1a686c30fc2e@6c48a","a3cd009f-0ab0-420d-9278-b9fdab939bbc","ab74804a-9a84-43a2-b0ac-7b535ce5739d","7812ec52-85c2-442f-90de-de56a3342451@73b7f","7812ec52-85c2-442f-90de-de56a3342451@e7d87","7812ec52-85c2-442f-90de-de56a3342451@438fe","0e414a05-411a-4f94-8c9e-78a672e57089"],["_parent","node","mainTexture","_effectAsset","root","data","_mesh","_skeleton","normalMaterial","instancingMaterial","_defaultClip"],[["cc.Node",["_name","_prefab","_parent","_euler","_lpos","_lrot","_children","_components","_lscale"],2,4,1,5,5,5,2,9,5],["cc.Material",["_states","_defines","_props"],1,12],["cc.Prefab",["_name"],2],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_lscale","_euler"],2,1,12,4,5,5,5,5],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_euler"],2,1,9,4,5,5,5],["cc.SkeletalAnimation",["playOnLoad","node","__prefab","_clips","_defaultClip"],2,1,4,3,6],["cc.CompPrefabInfo",["fileId"],2],["62579N1fFdIdbaTNEdZclqj",["triangle","vertex","node","__prefab"],1,1,4],["cc.PrefabInfo",["fileId","root","asset"],2,1,1],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],2,1,4,3,4,1,6,6],["cc.ModelLightmapSettings",[],3],["bcf19WXQ/FNSoaaPEqPFbYb",["node","__prefab","normalMaterial","instancingMaterial"],3,1,4,6,6],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[8,0,1,2,2],[0,0,2,6,1,4,5,3,2],[4,0,1,2,3,4,5,6,2],[0,0,6,1,4,5,3,2],[6,0,2],[0,0,2,1,4,5,8,3,2],[1,0,1,2,3],[0,0,2,1,4,3,2],[0,0,2,1,4,2],[2,0,2],[0,0,6,7,1,2],[0,0,2,6,1,2],[0,0,2,7,1,5,8,3,2],[0,0,2,1,4,5,3,2],[0,0,2,6,1,5,3,2],[3,0,1,2,3,4,5,6,7,2],[5,0,1,2,3,4,2],[7,0,1,2,3,3],[9,0,1,2,3,4,5,6,7,2],[10,1],[11,0,1,2,3,1],[12,0,1,2,3,4],[13,0,1,2,3],[14,0,1,2,4]],[[[[6,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true}],[[[{"alphaThreshold":0},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[0,1]],[[[9,"kulou"],[10,"kulou",[-4],[[16,true,-2,[4,"e1AJ+5cB1KhrnJiS7AFHx3"],[5],6],[17,588,304,-3,[4,"e8GazPZIxBh66N1S5vh3E2"]]],[0,"b4scyoOnRCdbA6CnSFy3VL",-1,0]],[3,"Bip001 Spine",[-5,-6,-7],[0,"5cHcC/RqZAJYpuUsQ/ub6z",1,0],[1,0.0247230138629675,-0.0111721474677324,-0.0000036899743918184],[3,0.04320789889985547,-0.006049274489872211,0.1179336090387913,0.9920625724267051],[1,5.142544526624373,-1.307869039403851,13.50158637556546]],[3,"Bip001 Neck",[-8,-9,-10],[0,"d2Xk+8aAtOSYlN46fKQmQI",1,0],[1,0.101416870951653,-0.015459050424397,0],[3,1.5482871972075537e-8,-5.24032376387713e-7,0.18542893349004877,0.9826576772327525],[1,0.000013829404414893772,-0.00006371909582819343,21.37228235075462]],[11,"RootNode",1,[-11,-12],[0,"3f0CqtjT1PZr059c4NCEG1",1,0]],[12,"Object02",4,[[18,1,-13,[4,"0f0kgapDBDHZTNhs/w9DPG"],[0],[19],1,1,2],[20,-14,[4,"4dyOJdITNMI75dNWHvxYb9"],3,4]],[0,"07bGxpGFtC5ZzoBwwf2lOg",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[15,"Bip001",4,[[[13,"Bip001 Footsteps",-15,[0,"b1VdMg6gBGMqh1MLY2Dgk1",1,0],[1,-2.22044599961948e-18,0,-0.149440377950668],[3,1.4385324958378064e-32,-2.1540844020696398e-32,0.7372769005543576,0.6755906837049783],[1,180,-180,85.00007399635209]],-16],4,1],[0,"3eDR/dqHJKYKk/NeuP2cUf",1,0],[1,0.000181087496457621,0.373808652162552,-0.0427427850663662],[3,0.4777147403987719,0.5213335082322389,0.5213335082322389,-0.4777147403987719],[1,2.54000020027161,2.54000020027161,2.53999996185303],[1,-89.99999999999999,-94.99992893924413,0]],[3,"Bip001 L Hand",[-17,-18],[0,"21hVyVM4JBeZKijIbu2j+I",1,0],[1,0.0764773935079575,-2.98023217215615e-10,0],[3,-0.8334472401528406,0.07292193368700775,-0.026828004762246966,0.5471090820206131],[1,-113.28059622478699,2.0332450237611552,-8.679599921946036]],[3,"Bip001 R Hand",[-19,-20],[0,"9b2YSJaaRJYassPDtA2Nmb",1,0],[1,0.0764773860573769,-9.53674295089968e-9,0],[3,0.7777910118302154,0.09997372927451915,0.1546499408418316,0.6009407551237416],[1,105.91587966009386,-7.36042914868613,19.961475769796]],[14,"Bip001 Pelvis",6,[2],[0,"9f/TcbK15EFpRTf02RA6ws",1,0],[3,-0.4999999925491744,-0.4999999925491744,-0.4999993070957696,0.5000007078049007],[1,-89.9999197452773,-89.9999197452773,-0.0000017074910412130916]],[1,"Bip001 Spine1",2,[3],[0,"3a8c3AFytEObbDab5c9pEG",1,0],[1,0.0559423416852951,-0.0000652217859169468,-0.0000164224948093761],[3,0.12397521100190256,-0.040589239811755606,0.19044597617448822,0.9729917732578646],[1,15.975391309372721,-7.776399009750924,21.13340087026386]],[1,"Bip001 L Clavicle",3,[-21],[0,"285vdQAOlFSburB0zXDBVR",1,0],[1,-0.0177527237683535,0.0334069430828094,0.0300718136131763],[3,0.7045896217940049,-0.05961499875002163,0.6777007142100324,0.2017950909795086],[1,158.16673978951135,-85.65812955609866,10.923905901114841]],[1,"Bip001 L UpperArm",11,[-22],[0,"60bUH2iERNxpNIfcMCQIzQ",1,0],[1,0.0320735089480877,9.53674295089968e-9,1.90734859017994e-8],[3,-0.14568595606347268,0.5800507075856524,-0.1710276903851499,0.7829855094168584],[1,-1.8940128649895063,72.62791573220686,-25.902108393146815]],[1,"Bip001 L Forearm",12,[7],[0,"7eWkvbUtRLkKxn6H3MrMfo",1,0],[1,0.0849168002605438,-2.38418573772492e-9,-9.53674295089968e-9],[3,-5.536714552742176e-18,-2.780220949187145e-17,-0.07381298590014837,0.9972721008393368],[1,-8.774520344759373e-16,-3.25955762921528e-15,-8.46604470365392]],[1,"Bip001 L Finger0",7,[-23],[0,"3eVC8TRmNKdLHbGg45taZT",1,0],[1,0.00654980633407831,0.00295660016126931,-0.0169793888926506],[3,0.42116257400363827,0.39984544971177244,0.04034595549832889,0.8130915732427358],[1,45.470646378697616,42.31030086966818,23.728912805974]],[2,"Bip001 L Finger01",14,[[7,"Bip001 L Finger0Nub",-24,[0,"69ixbxC69PwaIQ1/QawIj1",1,0],[1,0.01444146130234,9.53674295089968e-9,-9.53674295089968e-9],[1,8.537736462515943e-7,3.1805546814635294e-15,0.000001707547292503193]]],[0,"73f+IQqzNIDpwL/q9rif2I",1,0],[1,0.0203418806195259,0,0],[3,-1.218233518946223e-8,2.8200714765331812e-8,0.1620768166120055,0.98677814402069],[1,-0.000002006725681630389,0.0000036044653020093496,18.654925376785386]],[1,"Bip001 L Finger1",7,[-25],[0,"c8K42aq0pDyKqjCHKFVKOW",1,0],[1,0.0419518835842609,-9.53674295089968e-9,0],[3,-0.0003819575841966257,0.00011235737184126185,0.2821884678357794,0.9593589057827734],[1,-0.054265960050126266,0.02938256951790749,32.78171662500706]],[2,"Bip001 L Finger11",16,[[7,"Bip001 L Finger1Nub",-26,[0,"daSDFcGzNGh5NJ9hU6OPPy",1,0],[1,0.0186043065041304,-4.76837147544984e-9,0],[1,8.537736462515943e-7,0.0000025613209387547833,3.18055468146348e-15]]],[0,"04VLh4bHlLfJKyNc/CGGLC",1,0],[1,0.0203804578632116,-4.76837147544984e-9,-4.76837147544984e-9],[3,-1.5388552373848456e-8,6.383427447950232e-9,0.6548128604730067,0.7557910542995055],[1,-0.000012719352895008788,0.000011987814230131016,81.81092313691482]],[1,"Bip001 R Clavicle",3,[-27],[0,"4dh0yvozlPt7P66HMIVLFx",1,0],[1,-0.0177527237683535,0.0334071144461632,-0.0300717148929834],[3,0.7060253095284459,-0.03908647263714998,-0.6715422340388721,-0.22143066152664612],[1,-157.89070702154572,84.38046309026443,14.016895290135102]],[1,"Bip001 R UpperArm",18,[-28],[0,"04w/ariDtK7aDDf0npf/F6",1,0],[1,0.032073512673378,1.77635679969558e-17,0],[3,0.25346970164358396,-0.5043800990895652,-0.17411552099076655,0.8068690174627026],[1,16.057346316315524,-59.31769708160778,-32.457033016987964]],[1,"Bip001 R Forearm",19,[8],[0,"25/AmiBTRIfK1PtAvftImJ",1,0],[1,0.0849168002605438,2.38418573772492e-9,1.90734859017994e-8],[3,0,0,-0.15433462026861464,0.9880186359510343],[1,0,0,-17.756416919771123]],[1,"Bip001 R Finger0",8,[-29],[0,"22hQcGVp1JGJYOzZkDxfgx",1,0],[1,0.00654980633407831,0.00295661925338209,0.0169793888926506],[3,-0.421162520079432,-0.3998454849070189,0.04034594859191516,0.8130915842093259],[1,-45.47063895014861,-42.310306719780556,23.72891131496394]],[2,"Bip001 R Finger01",21,[[5,"Bip001 R Finger0Nub",-30,[0,"68l08Kjh1NJrIuTJ0wKNxh",1,0],[1,0.0144414659589529,0,2.38418573772492e-9],[3,-3.64291896867905e-17,3.7252898543727e-9,1,-1.11758708953857e-8],[1,-1,-1.00000011920929,-1],[1,-179.99999957311323,-180,-0.0000012806604693773861]]],[0,"a8rJsVn6NHN7Oi4LFvKD7X",1,0],[1,0.0203418768942356,0,-7.15255721317476e-9],[3,-1.3443238543751396e-8,1.2892790855445228e-8,0.16207683112173046,0.9867781416374898],[1,-0.000001857136623595293,0.0000018022326885808845,18.654927061755856]],[1,"Bip001 R Finger1",8,[-31],[0,"aaCfDEbmZHNZFLEcniZFgZ",1,0],[1,0.0419518873095512,9.53674295089968e-9,0],[3,0.0003819763593766548,-0.00011235186488561892,0.28218844040477686,0.9593589138445733],[1,0.05426820127211358,-0.029382569174469342,32.781713348221686]],[2,"Bip001 R Finger11",23,[[5,"Bip001 R Finger1Nub",-32,[0,"c5Q+qymQpOuqAkxGiJPKcW",1,0],[1,0.0186043120920658,-1.77635679969558e-17,0],[3,6.98491875450458e-10,5.58793544769287e-9,1,-6.51354704502062e-17],[1,-1,-1,-1.00000011920929],[1,-179.99999935966977,-179.99999991995875,-7.016709640256468e-15]]],[0,"d4usPOOX1MG6BGq8syEmI8",1,0],[1,0.0203804671764374,-4.76837147544984e-9,0],[3,1.2537386899926658e-8,-1.1626221551156213e-8,0.6548128604730067,0.7557910542995055],[1,0.000013747621095577127,-0.000013673601835632655,81.81092313691477]],[2,"Bip001 Head",3,[[8,"Bip001 HeadNub",-33,[0,"fdG62vs2dL6aR0A8F9L+rJ",1,0],[1,0.235991284251213,0,0]]],[0,"c9Dcku3ZtPEpkq+hEcOrkT",1,0],[1,0.0310295093804598,0,0],[3,-0.14530619924121743,0.10523767729660273,-0.5045447926572577,0.8445387450802555],[1,-17.24212020448052,3.799431259163884,-61.981825022828346]],[1,"Bip001 L Thigh",2,[-34],[0,"aekD755LRPL6FB72I6BYiX",1,0],[1,-0.0209244340658188,0.0185196306556463,0.0215458534657955],[3,0.5027952108959441,0.8634972425911256,0.014092690072415322,-0.03702545103234917],[1,-7.104555861092794,-170.97224381352464,60.14419285047008]],[1,"Bip001 L Calf",26,[-35],[0,"32CNnW/J1HB46jMJ3Moku8",1,0],[1,0.0810825601220131,9.53674295089968e-9,0],[3,-1.9478498500456166e-18,-2.8710522672090452e-18,-0.5614295545703493,0.8275245345335321],[1,-9.995267326823745e-16,-1.0756928242108098e-15,-68.30943745442528]],[1,"Bip001 L Foot",27,[-36],[0,"2az2CeKMNAi5Ess9ptNCzC",1,0],[1,0.0777051076292992,2.98023206113385e-9,-2.38418573772492e-9],[3,0.10914803307547477,-0.010296789939855288,0.18743541856006032,0.9761396656533862],[1,13.467573537305519,-3.7557945454536608,21.32628070451604]],[2,"Bip001 L Toe0",28,[[5,"Bip001 L Toe0Nub",-37,[0,"e8THSxkA9FIbTOrS8VwF9T",1,0],[1,0.00284749502316117,2.77555749952435e-19,-4.44089199923895e-18],[3,-4.203581926987e-14,-1.32348898008484e-22,1,-6.12323426292584e-17],[1,-1,-1,-1],[1,180,179.9999999999952,-7.016709604711002e-15]]],[0,"48rdIZpxtH2r/CibOl46Wh",1,0],[1,0.0218307878822088,0.0385080948472023,2.38418573772492e-9],[3,3.754560870366318e-7,1.647219634980865e-7,0.7071068705934472,0.7071066917795177],[1,0,0.00006084527110203374,90]],[1,"Bip001 R Thigh",2,[-38],[0,"4duDvQ/iRNzIW7rbiXmMBM",1,0],[1,-0.0219256393611431,0.01471630576998,-0.0233964007347822],[3,0.2718584193527665,0.9545369582944973,-0.10080267318558668,0.06921716662465059],[1,15.460216402406152,167.49040829709875,30.33422453439276]],[1,"Bip001 R Calf",30,[-39],[0,"c4arsYFBlIn5W6sO3uK/RN",1,0],[1,0.0810825526714325,2.38418573772492e-9,-4.76837147544984e-9],[3,0,0,-0.5516494323381922,0.8340760779455016],[1,0,0,-66.960489333418]],[1,"Bip001 R Foot",31,[-40],[0,"d1qSZ900tIRKlPsrpMzJSn",1,0],[1,0.0777051076292992,4.76837147544984e-9,4.76837147544984e-9],[3,-0.1946739713107787,-0.015993777742133418,0.409391047608343,0.8912043615836767],[1,-29.548011094140083,11.146529393591665,47.385800772675935]],[2,"Bip001 R Toe0",32,[[8,"Bip001 R Toe0Nub",-41,[0,"61fzy2T+tHTrP9D10jcRMo",1,0],[1,0.00284749618731439,1.49011608607807e-10,0]]],[0,"3d4+G52KND1qPTMKHpxsh3",1,0],[1,0.0218307878822088,0.038508091121912,-4.44089199923895e-18],[3,-9.65672998105575e-8,-5.442045129966375e-8,0.7071067811865431,0.7071067811865431],[1,0,-0.00001564940081280239,90]]],0,[0,4,1,0,1,1,0,1,1,0,-1,4,0,-1,10,0,-2,26,0,-3,30,0,-1,11,0,-2,18,0,-3,25,0,-1,5,0,-2,6,0,1,5,0,1,5,0,0,6,0,-2,9,0,-1,14,0,-2,16,0,-1,21,0,-2,23,0,-1,12,0,-1,13,0,-1,15,0,0,15,0,-1,17,0,0,17,0,-1,19,0,-1,20,0,-1,22,0,0,22,0,-1,24,0,0,24,0,0,25,0,-1,27,0,-1,28,0,-1,29,0,0,29,0,-1,31,0,-1,32,0,-1,33,0,0,33,0,5,1,2,0,9,3,0,10,7,0,13,8,0,20,41],[0,0,0,0,0,0,0],[-1,6,7,8,9,-1,10],[2,4,5,2,6,3,3]],[[[21,"Skin-0",2003325056,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","RootNode/Bip001/Bip001 Pelvis","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1/Bip001 L Finger11","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1/Bip001 R Finger11","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01"],[[[7,1.5893258265009536e-8,-0.7096582055091858,-0.7045462131500244,0,-6.123234262925839e-17,-0.7045462727546692,0.7096582055091858,0,-1.0000001192092896,-1.1278779687984297e-8,-1.1197533567042228e-8,0,0.02162030339241028,-0.02322281524538994,-0.030797986313700676,1],[7,-0.5774821639060974,-0.2760675251483917,-0.7683106064796448,0,-0.6007920503616333,-0.49349936842918396,0.6288937330245972,0,-0.5527779459953308,0.8247697949409485,0.11912789195775986,0,0.05640672892332077,-0.1012800931930542,-0.035364262759685516,1],[7,0.0000013867999086869531,0.0000027577068522077752,1,0,6.123234262925839e-17,-1,0.0000027577068522077752,0,1,-3.8243271396898315e-12,-0.0000013868001360606286,0,-0.1189260184764862,0.006147454027086496,1.479737363752065e-7,1],[7,0.4015420377254486,-0.4984605312347412,-0.768310546875,0,0.6185028553009033,-0.4711121916770935,0.6288938522338867,0,-0.6754392385482788,-0.7277296185493469,0.11912788450717926,0,0.10424035787582397,-0.0007083991076797247,-0.03536425903439522,1],[7,0.000001747388864714594,-0.000001917435611176188,1,0,-0.6789347529411316,-0.7341985106468201,-2.2141516353713087e-7,0,0.7341985106468201,-0.6789347529411316,-0.000002584744379419135,0,-0.1421937197446823,0.13816533982753754,4.918686045130016e-7,1],[7,6.771315383957699e-7,-0.000001581591732247034,1,0,-0.49392685294151306,-0.8695034384727478,-0.0000010407460422356962,0,0.8695034384727478,-0.49392688274383545,-0.0000013699587952942238,0,-0.30272504687309265,0.08865363895893097,6.412940933842037e-8,1],[7,4.1488510760245845e-7,-0.0000014576061175830546,1,0,-0.22306786477565765,-0.9748029708862305,-0.0000013283312227940769,0,0.9748029112815857,-0.22306789457798004,-7.295763566617097e-7,0,-0.13616546988487244,0.04892684891819954,1.294226024128875e-7,1],[7,1.5893258265009536e-8,0.7096601128578186,-0.7045443058013916,0,-6.123234262925839e-17,-0.7045443058013916,-0.709659993648529,0,-1.0000001192092896,1.1278810774228987e-8,-1.1197504257154378e-8,0,0.02162030152976513,-0.02322281524538994,0.030797988176345825,1],[7,0.5774837136268616,0.2760690152645111,-0.7683088779449463,0,-0.6007904410362244,-0.4934985935688019,-0.6288958787918091,0,-0.5527780055999756,0.8247697353363037,-0.11912773549556732,0,0.05640673637390137,-0.1012800931930542,0.03536425903439522,1],[7,-0.40154388546943665,0.49846163392066956,-0.7683087587356567,0,0.6185018420219421,-0.47111082077026367,-0.6288958787918091,0,-0.6754391193389893,-0.7277296185493469,-0.11912773549556732,0,0.10424036532640457,-0.0007083911332301795,0.03536425158381462,1],[7,0.5008148550987244,0.18276840448379517,0.8460378646850586,0,-0.09957904368638992,0.9831281304359436,-0.15343768894672394,0,-0.8598072528839111,-0.007403771858662367,0.5105651021003723,0,0.09096632897853851,0.01662791520357132,-0.1836102306842804,1],[7,0.5331219434738159,0.0008899393724277616,0.8460379838943481,0,0.24189835786819458,0.9580929279327393,-0.1534375101327896,0,-0.8107196092605591,0.28645607829093933,0.5105651021003723,0,0.1760968118906021,-0.015413153916597366,-0.183610200881958,1],[7,0.979061484336853,0.2035648673772812,0.000001785888684935344,0,-0.14956586062908173,0.7193548679351807,-0.678350031375885,0,-0.13808952271938324,0.6641460061073303,0.7347388863563538,0,-0.003220055950805545,-0.1322374939918518,-0.21500693261623383,1],[7,0.4923902451992035,-0.8639571070671082,-0.10549773275852203,0,0.004638511221855879,-0.11860307306051254,0.9929309487342834,0,-0.8703622221946716,-0.4893988072872162,-0.0543915256857872,0,0.021322568878531456,0.1722400188446045,0.0638580173254013,1],[7,-0.053763583302497864,-0.9928918480873108,-0.10618498921394348,0,-0.0607447512447834,-0.10288979113101959,0.9928361773490906,0,-0.9967042207717896,0.05982862412929535,-0.05478125438094139,0,0.07588621228933334,0.15593574941158295,0.06399504840373993,1],[7,-0.6205953359603882,-0.7769079208374023,-0.10618563741445541,0,-0.10921765863895416,-0.048454832285642624,0.9928361177444458,0,-0.7764873504638672,0.6277468800544739,-0.054781224578619,0,0.13577093183994293,0.09467355161905289,0.06399514526128769,1],[7,0.050690922886133194,-0.4967772960662842,0.8663963675498962,0,-0.6564680933952332,0.6371983289718628,0.40376731753349304,0,-0.7526487708091736,-0.5892289876937866,-0.29381823539733887,0,0.02830730937421322,0.1706569641828537,-0.07405880093574524,1],[7,-0.23688162863254547,-0.43959593772888184,0.8663963079452515,0,-0.18565593659877777,0.8958258628845215,0.40376758575439453,0,-0.9536346197128296,-0.06520649790763855,-0.29381823539733887,0,0.10237986594438553,0.13676847517490387,-0.07405876368284225,1],[7,-0.9790611267089844,-0.2035665661096573,-0.000001694710590527393,0,-0.14956940710544586,0.7193541526794434,0.6783499717712402,0,-0.1380881518125534,0.6641463041305542,-0.7347390055656433,0,-0.003220266429707408,-0.1322375237941742,0.21500693261623383,1],[7,0.0000017000606931105722,-0.000001826932248150115,1,0,-0.6394774317741394,-0.7688097953796387,-3.1741291195430676e-7,0,0.7688097953796387,-0.6394774317741394,-0.000002475305564075825,0,-0.25132524967193604,0.14063313603401184,4.558784496566659e-7,1],[7,-0.5008146166801453,-0.18277108669281006,0.8460375666618347,0,-0.09958040714263916,0.9831275939941406,0.15343999862670898,0,-0.8598072528839111,-0.007403770927339792,-0.5105651617050171,0,0.09096647053956985,0.016627997159957886,0.18361012637615204,1],[7,-0.5331225991249084,-0.0008925714064389467,0.8460375666618347,0,0.2418968677520752,0.9580929279327393,0.15343984961509705,0,-0.8107194900512695,0.28645607829093933,-0.5105651617050171,0,0.17609697580337524,-0.015413128770887852,0.18361012637615204,1],[7,-0.4923902750015259,0.8639575242996216,-0.10549498349428177,0,0.004637161735445261,-0.11860069632530212,-0.9929311871528625,0,-0.8703621625900269,-0.48939886689186096,0.0543915256857872,0,0.02132270485162735,0.17223992943763733,-0.0638580471277237,1],[7,0.05376367270946503,0.9928920269012451,-0.10618291795253754,0,-0.060744594782590866,-0.10288774222135544,-0.9928363561630249,0,-0.9967042207717896,0.05982857942581177,0.05478120595216751,0,0.07588626444339752,0.15593557059764862,-0.06399518251419067,1],[7,0.6205956339836121,0.7769080996513367,-0.10618289560079575,0,-0.10921594500541687,-0.048452701419591904,-0.9928363561630249,0,-0.776487410068512,0.6277468800544739,0.054781220853328705,0,0.13577090203762054,0.09467340260744095,-0.06399517506361008,1],[7,-0.0506892204284668,0.49677568674087524,0.8663975596427917,0,-0.6564682126045227,0.6371995806694031,-0.40376508235931396,0,-0.752648651599884,-0.5892289876937866,0.29381829500198364,0,0.028307320550084114,0.1706569641828537,0.07405859231948853,1],[7,0.2368820309638977,0.4395935833454132,0.8663974404335022,0,-0.18565526604652405,0.8958268761634827,-0.4037654399871826,0,-0.9536346197128296,-0.06520646065473557,0.2938181459903717,0,0.10237987339496613,0.13676846027374268,0.07405856251716614,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[22,".bin",4289299472,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":31320,"length":3528,"count":1764,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":31320,"count":435,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]]},"minPosition",8,[1,-0.17264027893543243,-0.27361854910850525,0.0003458127612248063],"maxPosition",8,[1,0.17264029383659363,0.03223412483930588,0.5379600524902344]]],-1],0,0,[],[],[]],[[[23,"builtin-unlit",[{"hash":1502294929,"name":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":2,"defines":["USE_TEXTURE"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  layout(location = 14) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture2D(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":198,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":41}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}]}],[{"name":"opaque","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"transparent","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"add","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]}]]],0,0,[],[],[]],[[[6,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_TEXTURE":true}],[[[{"alphaThreshold":0},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[0,1]]]]
