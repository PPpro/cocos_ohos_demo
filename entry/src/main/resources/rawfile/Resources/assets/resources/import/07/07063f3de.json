[1,["1a0e7476-929d-4223-9fa3-0cce14c04730","1baf0fc9-befa-459c-8bdd-af1a450a0319","900996a8-07d8-4115-8643-d76eee0a9baa@0089c","900996a8-07d8-4115-8643-d76eee0a9baa@3effa","0879af65-93c4-4797-b3bd-7204f659d744","900996a8-07d8-4115-8643-d76eee0a9baa@30732","3c095f45-531b-4735-b741-3331939d1979","900996a8-07d8-4115-8643-d76eee0a9baa@221a5","900996a8-07d8-4115-8643-d76eee0a9baa@709d0","d288441b-549c-428b-914e-b08cdebfed9a","900996a8-07d8-4115-8643-d76eee0a9baa@235da","6fa1803d-840f-4a59-abf7-1c0694112afd","900996a8-07d8-4115-8643-d76eee0a9baa@a412e","900996a8-07d8-4115-8643-d76eee0a9baa@f1394","f736e0ed-7419-4491-aef5-29d1258932f5"],["_parent","node","mainTexture","_effectAsset","_mesh","_skeleton","normalMaterial","instancingMaterial","root","data"],[["cc.Node",["_name","_prefab","_parent","_children","_lpos","_lrot","_euler","_lscale","_components"],2,4,1,2,5,5,5,5,9],["cc.Node",["_name","_children","_prefab","_lscale","_lpos","_lrot","_euler","_parent"],2,12,4,5,5,5,5,1],["cc.Material",["_states","_defines","_props"],1,12],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Prefab",["_name"],2],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_lscale","_euler"],2,1,9,4,5,5,5,5],["0bf7bClfXBJuYDk+fw5iW3V",["triangles","vertices","node","__prefab"],1,1,4],["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["fileId","root","asset"],2,1,1],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["cc.ModelLightmapSettings",[],3],["bcf19WXQ/FNSoaaPEqPFbYb",["node","__prefab","normalMaterial","instancingMaterial"],3,1,4,6,6],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12]],[[8,0,1,2,2],[0,0,2,3,1,4,5,7,6,2],[0,0,2,1,4,5,7,6,2],[5,0,1,2,3,4,5,6,7,2],[7,0,2],[2,0,1,2,3],[0,0,2,1,4,2],[0,0,2,1,4,5,6,2],[1,0,7,1,2,4,5,3,6,2],[1,0,1,2,4,5,3,6,2],[0,0,2,1,2],[0,0,2,3,1,2],[0,0,2,8,1,2],[9,0,1,2,3,4,5,6,1],[10,1],[11,0,1,2,3,1],[12,0,1,2,3],[0,0,3,1,4,5,7,6,2],[13,0,1,2,3,4],[3,0,1,2,4],[4,0,2],[0,0,3,8,1,4,2],[0,0,3,1,2],[0,0,2,3,1,5,6,2],[1,0,1,2,3,2],[1,0,7,1,2,3,2],[1,0,1,2,2],[6,0,1,2,3,3]],[[[[5,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[2,1]],[[[5,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[3,1]],[[[19,"builtin-standard",[{"hash":2489015834,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":["HAS_SECOND_UV"]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out lowp vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out mediump vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) in mediump vec2 v_uv1;\n#endif\nlayout(location = 4) in mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":223,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":2052537501,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":["HAS_SECOND_UV"]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) out vec2 v_uv1;\n#endif\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) in vec2 v_uv1;\n#endif\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":184,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[20,"14.8"],[21,"14.8",[-3],[[27,14.8,7.5,-2,[4,"3aZ1Cmf3NNPo5EXXO6a4Pv"]]],[0,"6amciaLlFGt5A3/bw2sLa/",-1,0],[1,2.43,0,-0.553]],[9,"pelvis_M_MED_Marshmellow_DJ.ao",[[-4,-5,-6,[2,"dyn_Grenade_Front_M_MED_Marshmellow_DJ.ao",-7,[0,"1a1sDOW39J55VKiO1Qcq0w",1,0],[1,3.1442599296569824,5.042129993438721,-15.137189865112305],[3,-0.012666292237601557,0.7069933274373612,0.012666292237601557,0.7069933274373612],[1,1,1.0000017881393433,1.0000017881393433],[1,-2.0527703106997057,90.00000000000003,0]],[2,"dyn_Grenade_Back_M_MED_Marshmellow_DJ.ao",-8,[0,"2ffhoG/YpC147lS6f5vPi5",1,0],[1,3.009660005569458,13.659199714660645,-7.095640182495117],[3,-0.012666292237601557,0.7069933274373612,0.012666292237601557,0.7069933274373612],[1,1,1.0000017881393433,1.0000017881393433],[1,-2.0527703106997057,90.00000000000003,0]]],1,1,1,4,4],[0,"a6A2vBBw9Ce5ywca+yNRdz",1,0],[1,0,0.7071300148963928,93.11913299560547],[3,0.012666292237601557,-0.7069933274373612,-0.012666292237601557,0.7069933274373612],[1,1.0000017881393433,1.0000017881393433,1],[1,0,-90.00000000000003,-2.052770310699706]],[17,"hand_l_M_MED_Marshmellow_DJ.ao",[-9,-10,-11,-12,-13],[0,"66u35sAqlMe46N9q1l+pLE",1,0],[1,22.349149703979492,0,0],[3,-0.7081026498406547,0.05067927754254616,0.0975342245063695,0.6975022029831517],[1,1.0000064373016357,0.9999938607215881,0.9999998807907104],[1,-91.25429663460758,12.078942014887557,3.6859966662200416]],[17,"hand_r_M_MED_Marshmellow_DJ.ao",[-14,-15,-16,-17,-18],[0,"f3F9NTlPRD0JFlJLBtwqA4",1,0],[1,-22.349069595336914,0.0002300000051036477,0.0002699999895412475],[3,-0.7080991294676866,0.05067928100308182,0.09753423144741956,0.6975057756177193],[1,1.000006079673767,0.9999933242797852,1.0000004768371582],[1,-91.25372425147425,12.078924654806414,3.686057440110817]],[24,"M_MED_Marshmellow_DJ.ao",[[-19,-20,-21,[10,"M_MED_Marshmellow_DJ.mo",-22,[0,"4c7i1vjRpBG55FNbbjBDe3",1,0]]],1,1,1,4],[0,"7cQ0Zc/wdIS4Q4AyLhMyBh",1,0],[1,0.010000000000000002,0.010000000000000002,0.010000000000000002]],[22,"Root",[-23,5,-24],[0,"d0usorH6dM6Y9Ti/VH3OGi",1,0]],[9,"spine_04_M_MED_Marshmellow_DJ.ao",[[-25,[2,"lowClip_M_MED_Marshmellow_DJ.ao",-26,[0,"de3THch9hH27HBJxI/a7CU",1,0],[1,1.3246500492095947,-15.432040214538574,-2.644170045852661],[3,0.05446159368769037,0.5639224546657736,0.008759572943840627,0.8239834159851561],[1,0.9999983906745911,0.999995231628418,1.0000009536743164],[1,4.594444525436629,68.5997483162373,4.350621186331782]],[2,"topClip_M_MED_Marshmellow_DJ.ao",-27,[0,"ef9wP7CKpBjZ1x4vsv05Vt",1,0],[1,4.978630065917969,-13.995499610900879,-8.128029823303223],[3,0.10339229756505769,-0.20863497665993677,0.0490229027637197,0.9712766003167919],[1,1.0000050067901611,0.9999946355819702,0.9999976754188538],[1,12.803122270208469,-24.581450492022775,2.9857219691421824]]],1,4,4],[0,"4dZp1J7qdNeKImYpnfgjTp",1,0],[1,8.102359771728516,-0.000019999999494757503,0],[3,0,0,-0.01315618864598844,0.9999134536050164],[1,0.9999961853027344,0.9999961853027344,1],[1,0,0,-1.5076316613988454]],[1,"spine_05_M_MED_Marshmellow_DJ.ao",7,[-28,-29,-30],[0,"2bIMOUzfZGEbasQeaFx2PX",1,0],[1,10.014610290527344,-0.000039999998989515007,0],[3,0,0,-0.0014949950461191942,0.9999988824942815],[1,1.0000044107437134,1.0000044107437134,1],[1,0,0,-0.1713138768859418]],[9,"upperarm_l_M_MED_Marshmellow_DJ.ao",[[-31,[6,"upperarm_twist_01_l_M_MED_Marshmellow_DJ.ao",-32,[0,"18nL5dQexFy7Jpfm/H+AMH",1,0],[1,0.004089999943971634,0,0]],[6,"upperarm_twist_02_l_M_MED_Marshmellow_DJ.ao",-33,[0,"5bzlFhRaVGfLdFDuPc3xde",1,0],[1,13.794099807739258,-0.000009999999747378752,0]]],1,4,4],[0,"a8g0/+Z11EZJiZCYViMzI1",1,0],[1,15.511090278625488,0,-0.000019999999494757503],[3,0.0304604968254395,0.5359817052419347,-0.005744651323985071,0.8436603396866901],[1,0.9999967217445374,1.0000044107437134,0.9999938607215881],[1,3.3003346392419495,64.81810307474481,1.315596279124369]],[8,"lowerarm_l_M_MED_Marshmellow_DJ.ao",9,[[3,[6,"lowerarm_twist_01_l_M_MED_Marshmellow_DJ.ao",-34,[0,"85L81KdwdNO7O1kbHlV48O",1,0],[1,17.854860305786133,0,0]],[6,"lowerarm_twist_02_l_M_MED_Marshmellow_DJ.ao",-35,[0,"25woA/rHBJhZrDoBwHI5U+",1,0],[1,9.61987018585205,0,0]]],1,4,4],[0,"dbhjtFpZVMHaiOiBwyw70S",1,0],[1,26.65135955810547,-0.000009999999747378752,-0.000009999999747378752],[3,0.03905840101510181,0.009890756274645578,-0.24526155753178036,0.9686193177133855],[1,1.0000033378601074,0.9999929666519165,1],[1,5.247729384513616,2.4948045138767174,-28.31752716305942]],[9,"upperarm_r_M_MED_Marshmellow_DJ.ao",[[-36,[7,"upperarm_twist_01_r_M_MED_Marshmellow_DJ.ao",-37,[0,"96/kD47hlB6buk+6KD/XTr",1,0],[1,-0.004100000020116568,0,0],[3,0,-0.00002499999936063438,0,0.9999999996875],[1,0,-0.002864788902686628,0]],[7,"upperarm_twist_02_r_M_MED_Marshmellow_DJ.ao",-38,[0,"d6YA7sMZ9KzJkHcTL4aWDr",1,0],[1,-13.793990135192871,0.000019999999494757503,-0.0009899999713525176],[3,0,-0.00002499999936063438,0,0.9999999996875],[1,0,-0.002864788902686628,0]]],1,4,4],[0,"dfu98TG+dMX59Og0sQzsbe",1,0],[1,-15.510899543762207,0.000029999999242136255,-0.00022000000171829015],[3,0.03046053644041566,0.5360138349840826,-0.00574465863185036,0.8436399251592009],[1,0.9999942779541016,1.000003457069397,0.9999921917915344],[1,3.3002888916796196,64.82246415031946,1.3157236274966382]],[8,"lowerarm_r_M_MED_Marshmellow_DJ.ao",11,[[4,[6,"lowerarm_twist_01_r_M_MED_Marshmellow_DJ.ao",-39,[0,"96rpIeknVMuL00XDSlNkNH",1,0],[1,-17.854820251464844,0.0001900000061141327,0.00019999999494757503]],[6,"lowerarm_twist_02_r_M_MED_Marshmellow_DJ.ao",-40,[0,"e4HGToEopN7oaN+NdCTX4T",1,0],[1,-9.619850158691406,0.00009999999747378752,0.00011000000085914508]]],1,4,4],[0,"2acZ1B2ohLVaUuOnSdWfD8",1,0],[1,-26.651140213012695,0.000039999998989515007,-0.0019199999514967203],[3,0.03906569633369792,0.00984886196383478,-0.245259374597472,0.9686200031281811],[1,1.0000020265579224,0.9999912977218628,0.9999971985816956],[1,5.247308187835594,2.4897390507758628,-28.317477457732515]],[25,"M_MED_Marshmallow_DJ_FaceAcc.ao",6,[[-41,-42,[10,"M_MED_Marshmallow_DJ_FaceAcc.mo",-43,[0,"f4IASSv0pNGIi4hhmGPL0U",1,0]]],1,1,4],[0,"ecvxrbaihOJ4GnWLbZRw1Q",1,0],[1,0.010000000000000002,0.010000000000000002,0.010000000000000002]],[9,"spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao",[[[2,"clavicle_l_M_MED_Marshmallow_DJ_FaceAcc.ao",-44,[0,"c6gIqTAMRM1K4DG1i5YtzR",1,0],[1,4.3574700355529785,0.14656999707221985,-2.322319984436035],[3,0.046476972450856656,0.7289303724357677,-0.008988036265009002,0.6829492062932311],[1,0.9999996423721313,1.0000051259994507,0.9999973773956299],[1,4.399151867672421,93.60843704185324,3.180414840646881]],[2,"clavicle_r_M_MED_Marshmallow_DJ_FaceAcc.ao",-45,[0,"49iUtcwkZFvpaHQzLi2H2j",1,0],[1,4.357560157775879,0.14655999839305878,2.3223299980163574],[3,0.7289319640612316,-0.046476755255487605,-0.6829475207800078,-0.008988150599429808],[1,1.0000118017196655,1.0000044107437134,0.9999964237213135],[1,-175.60086305609065,86.39129594690907,-3.180397937376275]],-46],4,4,1],[0,"85IiJ4IwRKlIQWQbFZQxZa",1,0],[1,10.014610290527344,-0.000039999998989515007,0],[3,0,0,-0.0014949950461191942,0.9999988824942815],[1,1.0000044107437134,1.0000044107437134,1],[1,0,0,-0.1713138768859418]],[8,"thigh_l_M_MED_Marshmellow_DJ.ao",2,[[-47,[2,"thigh_twist_01_l_M_MED_Marshmellow_DJ.ao",-48,[0,"4d2LyVgHlEvoqAcZAKFHWc",1,0],[1,-21.63028907775879,0,0],[3,0.0012699969817397462,0,0,0.999999193553508],[1,1,1.0000032186508179,1.0000032186508179],[1,0.1455309732170641,0,0]]],1,4],[0,"feqDVyO8FBwbv6P5oG+KRf",1,0],[1,-2.5693199634552,0.010870000347495079,-7.750070095062256],[3,0.0012371450151048818,-0.057160350137565,0.015462181182524057,0.9982445015112489],[1,1.000003695487976,1.0000022649765015,0.9999958276748657],[1,0.24291167899116076,-6.558188251858919,1.7608987729901524]],[8,"calf_l_M_MED_Marshmellow_DJ.ao",15,[[[2,"calf_twist_02_l_M_MED_Marshmellow_DJ.ao",-49,[0,"eaNxmsi4BPI5XNpmqygRkk",1,0],[1,-18.80636978149414,0.09670999646186829,0.03971000015735626],[3,0.02372543317167994,-0.009535729843533278,-0.00352864035729663,0.9996668056779698],[1,0.999994695186615,1.0000035762786865,0.9999968409538269],[1,2.7150652024148787,-1.082851603060255,-0.4301468290458968]],-50],4,1],[0,"99vpqQochIKb2iyoLdvwzf",1,0],[1,-39.048439025878906,0.000009999999747378752,0],[3,0.0006381092720722947,0.01606439400061887,-0.039052396368997745,0.9991078212083961],[1,0.9999935626983643,1.000003695487976,0.9999969005584717],[1,0.1453893370407521,1.848008934221409,-4.4744544048481005]],[8,"thigh_r_M_MED_Marshmellow_DJ.ao",2,[[-51,[2,"thigh_twist_01_r_M_MED_Marshmellow_DJ.ao",-52,[0,"a5o6y/ewpJtpQh+8MJcPFf",1,0],[1,21.633779525756836,-0.00011000000085914508,-0.01119999960064888],[3,0.0012699969807237533,0.000039999904360420644,0,0.9999991927535125],[1,1,1.0000032186508179,1.0000032186508179],[1,0.1455309729842159,0.004583647706310805,0.000005821223440668975]]],1,4],[0,"8d/HxNwVFAbJNhdsTzU2mU",1,0],[1,-2.5691299438476562,0.010870000347495079,7.750060081481934],[3,0.05742374667852955,0.0012395244255766673,0.998229360129945,-0.01546355299273279],[1,0.9998414516448975,1.0000014305114746,0.9999985098838806],[1,-179.75634219860825,-173.41156362991597,-1.7609759029566299]],[8,"calf_r_M_MED_Marshmellow_DJ.ao",17,[[[2,"calf_twist_02_r_M_MED_Marshmellow_DJ.ao",-53,[0,"39eyRwBSZOzK1Q/Aw7QEzN",1,0],[1,18.80946922302246,-0.09633000195026398,-0.03959000110626221],[3,0.02372543317167994,-0.009535729843533278,-0.00352864035729663,0.9996668056779698],[1,0.999994695186615,1.0000035762786865,0.9999968409538269],[1,2.7150652024148787,-1.082851603060255,-0.4301468290458968]],-54],4,1],[0,"9fEbarSFdIo57KGx4i3RAG",1,0],[1,39.05498123168945,-0.00019999999494757503,-0.02022000029683113],[3,0.0006280754352801515,0.01632456674827784,-0.03905989546064667,0.9991033172842196],[1,1.0000051259994507,1.0000020265579224,1.0000030994415283],[1,0.14541882293212452,1.8778519783551533,-4.475295119840758]],[12,"M_MED_Marshmellow_DJ.mo_0",5,[[13,-55,[4,"68XtkGBZ9B87KIVV9SwZmm"],[0],[14],1,1,2],[15,-56,[4,"702B1kfJ5AWZoaeH6bwbxc"],3,4]],[0,"03A/CrYnlByJlB6x9aPnTJ",1,0]],[12,"M_MED_Marshmellow_DJ.mo_1",5,[[13,-57,[4,"7ewzLtetBO4oSLK3lsrtot"],[5,6,7,8,9,10,11],[14],1,12,13],[15,-58,[4,"20AoDfm3tJA6/jhOE8vHJM"],14,15]],[0,"64abCeLt1NZa5Kf+HlMBR/",1,0]],[26,"root_M_MED_Marshmallow_DJ_FaceAcc.ao",[[[10,"attach_M_MED_Marshmallow_DJ_FaceAcc.ao",-59,[0,"81JNpcO6dCuacrQX+t3p/p",1,0]],-60],4,1],[0,"5aY6WU1P9CQq9WS3y5/M1H",1,0]],[12,"M_MED_Marshmallow_DJ_FaceAcc.mo_0",13,[[13,-61,[4,"582UMzLJdFqJmbUUVIoNsd"],[16],[14],1,17,18],[15,-62,[4,"50VEV/2KtBNr3+bwCux3pN"],19,20]],[0,"30k320piRPj4LQUq0KcPJa",1,0]],[23,"RootNode (gltf orientation matrix)",1,[-63],[0,"d3e6xiCKBAyJGvw9SngYm7",1,0],[3,-0.7071067811865475,0,0,0.7071067811865477],[1,-89.99999999999999,0,0]],[11,"RootNode (model correction matrix)",23,[6],[0,"892h1qyCtBJquTgodSoxQm",1,0]],[3,"Lamp",6,[[10,"Lamp",-64,[0,"7dWBAukwxHJZ/ZNvUbihh0",1,0]]],[0,"871Dpy5HxNB7Zz3yJa79zF",1,0],[1,4.076250000000001,1.00545,5.903860000000001],[3,0.16907447008309556,0.2721706359913094,0.7558797583695019,0.5709491121494871],[1,0.9999976022971255,0.9999958273912948,0.9999961165424595],[1,-132.46611940376033,169.25583219357765,72.77939686833803]],[11,"M_MED_Marshmellow_DJ.ao_rootJoint",5,[-65],[0,"f8Z2pGoHpE0KRaTZEHZ0k1",1,0]],[11,"root_M_MED_Marshmellow_DJ.ao",26,[2],[0,"4e0sOMSfBACLELl4Mfzndd",1,0]],[1,"spine_01_M_MED_Marshmellow_DJ.ao",2,[-66],[0,"42b/rLvaZHbactcnQ10jf8",1,0],[1,6.749370098114014,0.6387799978256226,0],[3,0,0,0.03403482974015173,0.9994206473575374],[1,0.9999967217445374,0.9999967217445374,1],[1,0,0,3.900857554258071]],[1,"spine_02_M_MED_Marshmellow_DJ.ao",28,[-67],[0,"5bWagq96ZEn6VsL6AjRaCr",1,0],[1,7.251739978790283,0.03497999906539917,0],[3,0,0,0.023756734954072458,0.9997177689449768],[1,0.9999987483024597,0.9999987483024597,1],[1,0,0,2.7225774325451497]],[1,"spine_03_M_MED_Marshmellow_DJ.ao",29,[7],[0,"de5Gd+lc5G2J8qUBl5HlVT",1,0],[1,6.010459899902344,0.000029999999242136255,0],[3,0,0,0.01488160447348495,0.9998892627927828],[1,1.0000029802322388,1.0000029802322388,1],[1,0,0,1.7053692071665458]],[1,"clavicle_l_M_MED_Marshmellow_DJ.ao",8,[9],[0,"c04dOgeVNMPqrBCMuhowUb",1,0],[1,4.3574700355529785,0.14656999707221985,-2.322319984436035],[3,0.046476972450856656,0.7289303724357677,-0.008988036265009002,0.6829492062932311],[1,0.9999996423721313,1.0000051259994507,0.9999973773956299],[1,4.399151867672421,93.60843704185324,3.180414840646881]],[1,"index_metacarpal_l_M_MED_Marshmellow_DJ.ao",3,[-68],[0,"3fertsss9FdpCJsoGwkvk+",1,0],[1,1.653499960899353,-0.01827000081539154,-2.960020065307617],[3,0.015760518301246543,0.012366857137029693,-0.017331130462584114,0.9996490878424874],[1,0.9999961853027344,0.9999974370002747,1.0000032186508179],[1,1.8313359217207956,1.4489455141782461,-1.9633537412652227]],[1,"index_01_l_M_MED_Marshmellow_DJ.ao",32,[-69],[0,"f7cYQ7AY9GtaHC4jxiR3dT",1,0],[1,8.300820350646973,-0.03573000058531761,-0.0524200014770031],[3,-0.004371168047140557,-0.04845734263519064,0.09242039824278221,0.994530667613264],[1,0.9999951720237732,1.0000040531158447,1.000005841255188],[1,0.01529469875941117,-5.580348774574646,10.617611257315517]],[3,"index_02_l_M_MED_Marshmellow_DJ.ao",33,[[2,"index_03_l_M_MED_Marshmellow_DJ.ao",-70,[0,"7diXZmhzhMOLzCemZuCxkw",1,0],[1,2.557729959487915,0.12330000102519989,-0.025180000811815262],[3,-0.0010314908599900255,-0.0068458016181617105,0.2558383947298234,0.966694774377558],[1,1.0000016689300537,0.9999997019767761,0.9999933242797852],[1,0.09945361489696307,-0.8378047343906122,29.646634121210592]]],[0,"a30e0lmMBNOJCXuA9i+2sB",1,0],[1,3.358750104904175,0.3003599941730499,0.04520000144839287],[3,-0.0020468393021611853,-0.0027362373230954916,0.3225245127465394,0.946554944063888],[1,1.0000052452087402,0.9999968409538269,1.0000033378601074],[1,-0.1526454614340903,-0.27924050857441635,37.63185376995299]],[1,"middle_metacarpal_l_M_MED_Marshmellow_DJ.ao",3,[-71],[0,"50i0R+qBRAG4xxCffANqu0",1,0],[1,2.185610055923462,0.17252999544143677,-0.5983700156211853],[3,0.005979259365774013,-0.016799196782575444,-0.03285537703889078,0.9993010355466112],[1,1.0000063180923462,1.0000011920928955,0.9999922513961792],[1,0.6228102976693691,-1.9056777694567664,-3.776561664417623]],[1,"middle_01_l_M_MED_Marshmellow_DJ.ao",35,[-72],[0,"ddTTy7pKZKiIyYbQHT3xQa",1,0],[1,7.327499866485596,0.24473999440670013,0.012919999659061432],[3,-0.020831530571374404,-0.004193883785975392,0.08579102762619314,0.9960865214687353],[1,0.9999917149543762,1.0000016689300537,1.0000030994415283],[1,-2.3721885617489624,-0.2780096463652977,9.850926828817427]],[3,"middle_02_l_M_MED_Marshmellow_DJ.ao",36,[[7,"middle_03_l_M_MED_Marshmellow_DJ.ao",-73,[0,"e4srm/nkZNz7Y79Np9Qm3j",1,0],[1,2.607880115509033,-0.11522000283002853,0.004879999905824661],[3,0,0,0.17067432641570254,0.9853274959639288],[1,0,0,19.65405624558208]]],[0,"b9kIJ4aVZB56SMXB2qiKD6",1,0],[1,4.013040065765381,-0.0722000002861023,0.002950000111013651],[3,0,0,0.3510969541260995,0.9363391099400771],[1,0.9999975562095642,0.9999975562095642,1],[1,0,0,41.10884881904792]],[1,"pinky_metacarpal_l_M_MED_Marshmellow_DJ.ao",3,[-74],[0,"7fQCsumZZNfaavW4GjBAZx",1,0],[1,1.7615900039672852,0.9753000140190125,3.3814001083374023],[3,-0.039687971519463995,-0.08135616575084596,-0.06895799016688525,0.9935043204753237],[1,0.999995768070221,1.0000020265579224,0.9999987483024597],[1,-5.2129919563122895,-9.704800756116045,-7.502092456104337]],[1,"pinky_01_l_M_MED_Marshmellow_DJ.ao",38,[-75],[0,"90B1Eg+SpCA5dzdPZbNsxR",1,0],[1,7.170929908752441,0.4830799996852875,-0.10936000198125839],[3,-0.06542006032185228,0.003497035886156337,0.22422375922715407,0.9723331179413459],[1,0.9999955892562866,1.000001072883606,1.0000064373016357],[1,-8.225800062454557,2.3008569393670104,25.822385497043072]],[3,"pinky_02_l_M_MED_Marshmellow_DJ.ao",39,[[2,"pinky_03_l_M_MED_Marshmellow_DJ.ao",-76,[0,"85+5fP8dBLQpP8UQCEypNl",1,0],[1,2.204619884490967,-0.030750000849366188,-0.007790000177919865],[3,-0.0001969173245656919,-0.009826090963478274,0.14448274565292402,0.9894585111911148],[1,1.0000072717666626,0.9999979734420776,1.000002384185791],[1,0.1464735656442247,-1.159332237460637,16.614042656461354]]],[0,"99Gg3oPyJP7oA9w6sPKYGq",1,0],[1,2.827440023422241,-0.08924999833106995,-0.10434000194072723],[3,0.003714486146227955,-0.001105828108089792,0.28541487786928565,0.9583962266347491],[1,0.9999948740005493,1.0000020265579224,0.9999991655349731],[1,0.5305481302527656,-0.29021440741289845,33.16643036571157]],[1,"ring_metacarpal_l_M_MED_Marshmellow_DJ.ao",3,[-77],[0,"69Pu1IMoZBRICFTPKYkpSe",1,0],[1,2.207360029220581,0.36250999569892883,1.3638299703598022],[3,-0.028402842644781646,-0.07217844591782835,-0.04582126448863465,0.9959337137557127],[1,0.9999971389770508,1.0000025033950806,1.000004529953003],[1,-3.6367565400890136,-8.449179143830385,-5.000804940379015]],[1,"ring_01_l_M_MED_Marshmellow_DJ.ao",41,[-78],[0,"50nmpCcB9MQ5oI+SmvIZ6t",1,0],[1,7.029489994049072,0.6196799874305725,-0.14461000263690948],[3,-0.04890405715223545,0.025183694210605415,0.18923120030410437,0.9803905994915626],[1,0.9999934434890747,0.9999999403953552,1.0000033378601074],[1,-6.511655085387009,4.188014392556978,21.62793386300999]],[3,"ring_02_l_M_MED_Marshmellow_DJ.ao",42,[[7,"ring_03_l_M_MED_Marshmellow_DJ.ao",-79,[0,"aeRZViDPhD/YOISNe2tn1m",1,0],[1,2.415210008621216,-0.1140500009059906,0.01988999918103218],[3,0,0,0.1189136280077485,0.9929046022020619],[1,0,0,13.658818246121292]]],[0,"73e03Azb1Ku48UgZYgtCju",1,0],[1,3.6173999309539795,-0.46467000246047974,-0.10266999900341034],[3,0,0,0.2806324061215578,0.9598153221502692],[1,0.999998927116394,0.999998927116394,1],[1,0,0,32.59590459571711]],[1,"thumb_01_l_M_MED_Marshmellow_DJ.ao",3,[-80],[0,"1a3AmNGZJG44M5ZgN/9d0J",1,0],[1,1.3118000030517578,0.3191100060939789,-2.459009885787964],[3,0.6545734841463987,0.40419959033353786,0.0663633628349238,0.635414942458772],[1,1.0000038146972656,1.0000005960464478,0.9999949336051941],[1,80.2114507840411,32.71394666552241,37.84251587199913]],[3,"thumb_02_l_M_MED_Marshmellow_DJ.ao",44,[[2,"thumb_03_l_M_MED_Marshmellow_DJ.ao",-81,[0,"d1TsgE7/hGKqAJ5xZR2a02",1,0],[1,2.2223100662231445,-0.3682200014591217,-0.09070000052452087],[3,0.011812063014866122,0.0129597858481275,0.006553628061107033,0.9998247691857509],[1,1.0000014305114746,1.0000053644180298,0.9999949336051941],[1,1.343836905029809,1.4762471652440232,0.768423778793723]]],[0,"284mjnoE5ICI2QFugg9kaR",1,0],[1,5.933650016784668,0.044840000569820404,0.04010999947786331],[3,-0.0037069034408333656,-0.021313998912203543,0.2980235227951103,0.9543133406685895],[1,0.9999932646751404,1.0000042915344238,0.9999961853027344],[1,0.3921944993858502,-2.6813571686862283,34.67868727148087]],[1,"clavicle_r_M_MED_Marshmellow_DJ.ao",8,[11],[0,"a8M9uGeXVGqbmBSV33g0PL",1,0],[1,4.357560157775879,0.14655999839305878,2.3223299980163574],[3,0.7289319640612316,-0.046476755255487605,-0.6829475207800078,-0.008988150599429808],[1,1.0000118017196655,1.0000044107437134,0.9999964237213135],[1,-175.60086305609065,86.39129594690907,-3.180397937376275]],[1,"index_metacarpal_r_M_MED_Marshmellow_DJ.ao",4,[-82],[0,"0ecwB53KVKcaGxb0zSdNp3",1,0],[1,-1.6533700227737427,0.018079999834299088,2.9600698947906494],[3,0.01576056346940849,0.012364358763157692,-0.017331171951763136,0.9996491173158114],[1,0.999994695186615,0.9999973177909851,1.000004529953003],[1,1.8313362565457605,1.448659277014594,-1.9633630060022484]],[1,"index_01_r_M_MED_Marshmellow_DJ.ao",47,[-83],[0,"c5/9kcIv9CrptvjJDV9kwA",1,0],[1,-8.300749778747559,0.0356299988925457,0.05251000076532364],[3,-0.004371519660707326,-0.04845485457688913,0.09242287266636473,0.9945305573444616],[1,0.9999980926513672,1.0000026226043701,1.0000052452087402],[1,0.01524116922196078,-5.580058456986753,10.617897697120139]],[3,"index_02_r_M_MED_Marshmellow_DJ.ao",48,[[2,"index_03_r_M_MED_Marshmellow_DJ.ao",-84,[0,"e6QB9CY+xJ8J3fak3Jnl1H",1,0],[1,-2.5577900409698486,-0.12309999763965607,0.025140000507235527],[3,-0.0019962927764495112,-0.006698439660410111,0.25583288631185647,0.9666957535867277],[1,0.9999985694885254,1.0000030994415283,0.9999954700469971],[1,-0.028496761499916687,-0.7864748590460208,29.646797119358737]]],[0,"28gm+/wTtNvoPKGBuvgmef",1,0],[1,-3.3588500022888184,-0.3003599941730499,-0.045239999890327454],[3,-0.002044472144583982,-0.002730687614085994,0.32252785558220837,0.9465538261780713],[1,1.0000020265579224,0.9999963641166687,1.0000050067901611],[1,-0.15257941911075018,-0.27859095146222973,37.63225686418566]],[1,"middle_metacarpal_r_M_MED_Marshmellow_DJ.ao",4,[-85],[0,"7326ifn7dAwZnRUueVluKX",1,0],[1,-2.1856300830841064,-0.17264999449253082,0.5983899831771851],[3,0.005979259365774013,-0.016799196782575444,-0.03285537703889078,0.9993010355466112],[1,1.0000063180923462,1.0000011920928955,0.9999922513961792],[1,0.6228102976693691,-1.9056777694567664,-3.776561664417623]],[1,"middle_01_r_M_MED_Marshmellow_DJ.ao",50,[-86],[0,"a8U0Oo6XpK4YfFsMZeoAbX",1,0],[1,-7.327270030975342,-0.2447900027036667,-0.012849999591708183],[3,-0.020831532981869755,-0.004193934187690223,0.08579348857403989,0.9960863092463177],[1,0.9999961256980896,0.9999988675117493,1.0000032186508179],[1,-2.37218865841844,-0.27800963395089,9.851209938346308]],[3,"middle_02_r_M_MED_Marshmellow_DJ.ao",51,[[2,"middle_03_r_M_MED_Marshmellow_DJ.ao",-87,[0,"95RsBEXE9EoZsekI1Dqx7P",1,0],[1,-2.607419967651367,0.05339000001549721,-0.13120000064373016],[3,0.008298704559005797,-0.01876227755428629,0.17081192034914675,0.9850900447726874],[1,0.9999969601631165,1.000001311302185,1.0000020265579224],[1,1.3847710443405963,-2.4220600437003994,19.646671983903477]]],[0,"4eQJBI8b9KVKyRQB2cWPov",1,0],[1,-4.014170169830322,0.1410199999809265,-0.06993000209331512],[3,-0.021703318034202602,-0.02587180989715514,0.35124057972818784,0.9356760500254127],[1,1.0000029802322388,0.9999971985816956,1.000001311302185],[1,-1.7085079969927495,-2.525819583470574,41.17931693248179]],[1,"pinky_metacarpal_r_M_MED_Marshmellow_DJ.ao",4,[-88],[0,"08fp39f1tOcKPDg7nXhxPo",1,0],[1,-1.7617000341415405,-0.975350022315979,-3.38139009475708],[3,-0.039687971519463995,-0.08135616575084596,-0.06895799016688525,0.9935043204753237],[1,0.999995768070221,1.0000020265579224,0.9999987483024597],[1,-5.2129919563122895,-9.704800756116045,-7.502092456104337]],[1,"pinky_01_r_M_MED_Marshmellow_DJ.ao",53,[-89],[0,"b1vXusHu1NYql8FDPqzCHd",1,0],[1,-7.170650005340576,-0.4833199977874756,0.10943000018596649],[3,-0.0654195017578286,0.003499466883145763,0.2242236110021918,0.972333180957242],[1,0.9999954700469971,1.0000027418136597,1.0000046491622925],[1,-8.22579822379172,2.3011402183954575,25.82234895147415]],[3,"pinky_02_r_M_MED_Marshmellow_DJ.ao",54,[[2,"pinky_03_r_M_MED_Marshmellow_DJ.ao",-90,[0,"f4P70EDX9A0oytjXQEZu3x",1,0],[1,-2.2044999599456787,0.031029999256134033,0.007770000025629997],[3,-0.0001969417449600039,-0.009826084558140352,0.14448511661239002,0.9894581650346363],[1,1.0000064373016357,1.0000009536743164,1.0000030994415283],[1,0.14647356905499903,-1.1593322527588406,16.614317244007573]]],[0,"01wxIv8+FC8ap07BwkAfr8",1,0],[1,-2.827440023422241,0.08912999927997589,0.10433000326156616],[3,0.0037144758801975126,-0.0011058250748960466,0.2854188995316836,0.9583950289989832],[1,1.0000003576278687,1.000006914138794,0.9999997615814209],[1,0.5305495746560518,-0.2902170638344751,33.16691121130875]],[1,"ring_metacarpal_r_M_MED_Marshmellow_DJ.ao",4,[-91],[0,"818Dzmo+9PAIZUoddw3kvV",1,0],[1,-2.2072501182556152,-0.3626999855041504,-1.3637800216674805],[3,-0.028402842644781646,-0.07217844591782835,-0.04582126448863465,0.9959337137557127],[1,0.9999971389770508,1.0000025033950806,1.000004529953003],[1,-3.6367565400890136,-8.449179143830385,-5.000804940379015]],[1,"ring_01_r_M_MED_Marshmellow_DJ.ao",56,[-92],[0,"33VOjCfn9H6ZAl/TcrqFNs",1,0],[1,-7.029620170593262,-0.6198199987411499,0.144679993391037],[3,-0.04890357981770266,0.025186143332796364,0.18923104936789997,0.9803905895203996],[1,0.9999920129776001,1.0000016689300537,1.0000033378601074],[1,-6.511652554786135,4.188298138805298,21.62790210700716]],[3,"ring_02_r_M_MED_Marshmellow_DJ.ao",57,[[7,"ring_03_r_M_MED_Marshmellow_DJ.ao",-93,[0,"10glBtr8xJTroQGOvnDpI2",1,0],[1,-2.415260076522827,0.11415000259876251,-0.01988999918103218],[3,0,0,0.1189136280077485,0.9929046022020619],[1,0,0,13.658818246121292]]],[0,"8cIdZf5XpHzqsykLTOziPR",1,0],[1,-3.617140054702759,0.464709997177124,0.10266000032424927],[3,0,0,0.2806324061215578,0.9598153221502692],[1,0.999998927116394,0.999998927116394,1],[1,0,0,32.59590459571711]],[1,"thumb_01_r_M_MED_Marshmellow_DJ.ao",4,[-94],[0,"2fpB5+WztCR7bAMcz8s6qn",1,0],[1,-1.3118599653244019,-0.31922999024391174,2.458980083465576],[3,0.6545694385677683,0.4042007870806207,0.06636166486671828,0.6354185260539708],[1,1.0000057220458984,1.0000014305114746,0.9999958276748657],[1,80.21067064749933,32.714443024057076,37.84227020966845]],[3,"thumb_02_r_M_MED_Marshmellow_DJ.ao",59,[[2,"thumb_03_r_M_MED_Marshmellow_DJ.ao",-95,[0,"f3FZN3DMFMKItLAgNhzD1I",1,0],[1,-2.2223000526428223,0.3682200014591217,0.09070999920368195],[3,0.011812004359709569,0.012959720675477989,0.006553628071186062,0.9998247707234125],[1,1.0000014305114746,1.0000053644180298,1.0000050067901611],[1,1.3438302333429073,1.4762397414453192,0.768423605765149]]],[0,"d8m9d5MZxCH6hX4FSMQQga",1,0],[1,-5.933539867401123,-0.044780001044273376,-0.040049999952316284],[3,-0.0037069682990608565,-0.021313968526158036,0.2980268524932031,0.954312301253992],[1,0.9999998807907104,0.9999953508377075,0.9999960660934448],[1,0.3921969323201816,-2.6813585693188235,34.679087064616205]],[3,"neck_01_M_MED_Marshmellow_DJ.ao",8,[[2,"neck_02_M_MED_Marshmellow_DJ.ao",-96,[0,"97HcHyDw1BYKi9HA7ENtt3",1,0],[1,4.562650203704834,-0.000009999999747378752,0],[3,0,0,0.05042935733222001,0.9987276304974542],[1,0.9999962449073792,0.9999962449073792,1],[1,0,0,5.781230839371497]]],[0,"b0ldxJX+FMNJ89EnP3MF7n",1,0],[1,11.313850402832031,-0.15286000072956085,0],[3,0,0,-0.2002773424087497,0.979739243940799],[1,1.000002145767212,1.000002145767212,1],[1,0,0,-23.10635545154424]],[3,"foot_l_M_MED_Marshmellow_DJ.ao",16,[[2,"ball_l_M_MED_Marshmellow_DJ.ao",-97,[0,"7efTVjk8dKW7K6ls8X3jQj",1,0],[1,-6.159860134124756,-13.826410293579102,0.6805999875068665],[3,0.00006010395428233936,0.00006010395428233936,-0.7062825029583307,0.707930094564389],[1,1.0000027418136597,1.0000027418136597,1],[1,4.172893231049833,4.172893231049833,-89.86614329300954]]],[0,"69+DTsLddIA6pR3tOPSOP0",1,0],[1,-42.561031341552734,-0.10773999989032745,0.4291900098323822],[3,0.041784346319499364,0.045506134864305096,0.03428309055989888,0.9975008420016626],[1,1.000004529953003,1.0000003576278687,1.000003457069397],[1,4.6144095334407025,5.05717902003445,4.140226319606304]],[3,"foot_r_M_MED_Marshmellow_DJ.ao",18,[[2,"ball_r_M_MED_Marshmellow_DJ.ao",-98,[0,"dbbR/CPe1KwYOyFJeL2Fc2",1,0],[1,6.160799980163574,13.826430320739746,-0.680429995059967],[3,0.00007071053574327181,0.000049497372109907216,-0.7062789821038554,0.7079336070482685],[1,1.0000027418136597,1.0000027418136597,1],[1,4.156077124896562,4.154358253553418,-89.86557489639192]]],[0,"47xjwMVmBH1q7nzwRdUI9r",1,0],[1,42.56800079345703,0.10859999805688858,-0.4289200007915497],[3,0.04178431616699718,0.045511088786753966,0.03428805302757703,0.9975004466863555],[1,1.000005841255188,1.0000017881393433,1.0000039339065552],[1,4.614362006078962,5.0577268926318775,4.140817106873178]],[11,"M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint",13,[21],[0,"985Vp9xltK0bKsW1DgFTst",1,0]],[1,"pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao",21,[-99],[0,"9eXLlb+CBEurrYihrgLcBv",1,0],[1,0,0.7071300148963928,93.11913299560547],[3,0.012666292237601557,-0.7069933274373612,-0.012666292237601557,0.7069933274373612],[1,1.0000017881393433,1.0000017881393433,1],[1,0,-90.00000000000003,-2.052770310699706]],[1,"spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao",65,[-100],[0,"89VM/0pVlNlYImlzjhb1vn",1,0],[1,6.749370098114014,0.6387799978256226,0],[3,0,0,0.03403482974015173,0.9994206473575374],[1,0.9999967217445374,0.9999967217445374,1],[1,0,0,3.900857554258071]],[1,"spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao",66,[-101],[0,"f7NS+ZgddOnJ8RI7UQLIwA",1,0],[1,7.251739978790283,0.03497999906539917,0],[3,0,0,0.023756734954072458,0.9997177689449768],[1,0.9999987483024597,0.9999987483024597,1],[1,0,0,2.7225774325451497]],[1,"spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao",67,[-102],[0,"170Q83OGdLMYYZYde/l4l5",1,0],[1,6.010459899902344,0.000029999999242136255,0],[3,0,0,0.01488160447348495,0.9998892627927828],[1,1.0000029802322388,1.0000029802322388,1],[1,0,0,1.7053692071665458]],[1,"spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao",68,[14],[0,"behsEtOEhBPZNUYUz8UksI",1,0],[1,8.102359771728516,-0.000019999999494757503,0],[3,0,0,-0.01315618864598844,0.9999134536050164],[1,0.9999961853027344,0.9999961853027344,1],[1,0,0,-1.5076316613988454]],[1,"neck_01_M_MED_Marshmallow_DJ_FaceAcc.ao",14,[-103],[0,"5co8Wc4TZA8ZZih7gtLIhj",1,0],[1,11.313850402832031,-0.15286000072956085,0],[3,0,0,-0.2002773424087497,0.979739243940799],[1,1.000002145767212,1.000002145767212,1],[1,0,0,-23.10635545154424]],[3,"neck_02_M_MED_Marshmallow_DJ_FaceAcc.ao",70,[[7,"head_M_MED_Marshmallow_DJ_FaceAcc.ao",-104,[0,"3aLi+PnlhARKpMWA0CDkNe",1,0],[1,5.391419887542725,0.000029999999242136255,0],[3,0,0,0.11495707771229033,0.9933704597398951],[1,0,0,13.202298728000297]]],[0,"59pxJNnxpK+JnmgS2TRDmn",1,0],[1,4.562650203704834,-0.000009999999747378752,0],[3,0,0,0.05042935733222001,0.9987276304974542],[1,0.9999962449073792,0.9999962449073792,1],[1,0,0,5.781230839371497]]],0,[0,8,1,0,1,1,0,-1,23,0,-1,28,0,-2,15,0,-3,17,0,0,2,0,0,2,0,-1,32,0,-2,35,0,-3,38,0,-4,41,0,-5,44,0,-1,47,0,-2,50,0,-3,53,0,-4,56,0,-5,59,0,-1,26,0,-2,19,0,-3,20,0,0,5,0,-1,25,0,-3,13,0,-1,8,0,0,7,0,0,7,0,-1,31,0,-2,46,0,-3,61,0,-1,10,0,0,9,0,0,9,0,0,10,0,0,10,0,-1,12,0,0,11,0,0,11,0,0,12,0,0,12,0,-1,64,0,-2,22,0,0,13,0,0,14,0,0,14,0,-3,70,0,-1,16,0,0,15,0,0,16,0,-2,62,0,-1,18,0,0,17,0,0,18,0,-2,63,0,1,19,0,1,19,0,1,20,0,1,20,0,0,21,0,-2,65,0,1,22,0,1,22,0,-1,24,0,0,25,0,-1,27,0,-1,29,0,-1,30,0,-1,33,0,-1,34,0,0,34,0,-1,36,0,-1,37,0,0,37,0,-1,39,0,-1,40,0,0,40,0,-1,42,0,-1,43,0,0,43,0,-1,45,0,0,45,0,-1,48,0,-1,49,0,0,49,0,-1,51,0,-1,52,0,0,52,0,-1,54,0,-1,55,0,0,55,0,-1,57,0,-1,58,0,0,58,0,-1,60,0,0,60,0,0,61,0,0,62,0,0,63,0,-1,66,0,-1,67,0,-1,68,0,-1,69,0,-1,71,0,0,71,0,9,1,2,0,27,3,0,10,4,0,12,5,0,6,6,0,24,7,0,30,9,0,31,11,0,46,14,0,69,21,0,64,104],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,4,5,6,7,-1,-2,-3,-4,-5,-6,-7,4,5,6,7,-1,4,5,6,7],[4,8,5,9,4,0,0,0,0,0,0,0,10,5,11,0,6,12,13,14,6]],[[[5,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[7,1]],[[[5,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[3,1]],[[[16,".bin",2810497424,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":279504,"length":7764,"count":3882,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":582972,"length":8214,"count":4107,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":1049610,"length":12738,"count":6369,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":1300812,"length":6624,"count":3312,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":1745484,"length":12168,"count":6084,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":2128308,"length":10296,"count":5148,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[6],"indexView":{"offset":2245308,"length":2964,"count":1482,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":279504,"count":3882,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":287268,"length":295704,"count":4107,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":591186,"length":458424,"count":6367,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":1062348,"length":238464,"count":3312,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":1307436,"length":438048,"count":6084,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":1757652,"length":370656,"count":5148,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":2138604,"length":106704,"count":1482,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,3,4,5,6,7,8,12,13,14,15,17,25,33,35,60,61,62,67,68,69,70,71,72,73,74,75,76,77],[0,8,9,10,11,12,13,14,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],[0,2,3,4,5,6,7,8,33,34,35,39,40,41,42,44,45,46,52,60,61,62,66,71,72,73,74,75,77],[0,8,38,39,40,41,43,44,47,48,49,50,51,52,53,54,55,56,57,58,59,68,69,74,75],[0,2,3,4,5,6,7,8,29,30,33,34,35,36,37,58,59,60,61,62,66,67,68,69,71,72,77],[0,5,6,7,8,9,10,11,31,32,33,34,36,37,38,47,55,56,57,58,59,68,69,70,74,75,76],[0,6,7,8,35,53,54,62,69,70,75,76]]},"minPosition",8,[1,-37.43450164794922,-14.511099815368652,-0.1739400029182434],"maxPosition",8,[1,37.43450164794922,16.75735092163086,146.6354217529297]]],-1],0,0,[],[],[]],[[[18,"Skin-0",936737547,["RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/index_metacarpal_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/index_metacarpal_l_M_MED_Marshmellow_DJ.ao/index_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/index_metacarpal_l_M_MED_Marshmellow_DJ.ao/index_01_l_M_MED_Marshmellow_DJ.ao/index_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/index_metacarpal_l_M_MED_Marshmellow_DJ.ao/index_01_l_M_MED_Marshmellow_DJ.ao/index_02_l_M_MED_Marshmellow_DJ.ao/index_03_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/middle_metacarpal_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/middle_metacarpal_l_M_MED_Marshmellow_DJ.ao/middle_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/middle_metacarpal_l_M_MED_Marshmellow_DJ.ao/middle_01_l_M_MED_Marshmellow_DJ.ao/middle_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/middle_metacarpal_l_M_MED_Marshmellow_DJ.ao/middle_01_l_M_MED_Marshmellow_DJ.ao/middle_02_l_M_MED_Marshmellow_DJ.ao/middle_03_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_l_M_MED_Marshmellow_DJ.ao/pinky_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_l_M_MED_Marshmellow_DJ.ao/pinky_01_l_M_MED_Marshmellow_DJ.ao/pinky_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_l_M_MED_Marshmellow_DJ.ao/pinky_01_l_M_MED_Marshmellow_DJ.ao/pinky_02_l_M_MED_Marshmellow_DJ.ao/pinky_03_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/ring_metacarpal_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/ring_metacarpal_l_M_MED_Marshmellow_DJ.ao/ring_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/ring_metacarpal_l_M_MED_Marshmellow_DJ.ao/ring_01_l_M_MED_Marshmellow_DJ.ao/ring_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/ring_metacarpal_l_M_MED_Marshmellow_DJ.ao/ring_01_l_M_MED_Marshmellow_DJ.ao/ring_02_l_M_MED_Marshmellow_DJ.ao/ring_03_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/thumb_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/thumb_01_l_M_MED_Marshmellow_DJ.ao/thumb_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/hand_l_M_MED_Marshmellow_DJ.ao/thumb_01_l_M_MED_Marshmellow_DJ.ao/thumb_02_l_M_MED_Marshmellow_DJ.ao/thumb_03_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_twist_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_l_M_MED_Marshmellow_DJ.ao/lowerarm_twist_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/upperarm_twist_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_l_M_MED_Marshmellow_DJ.ao/upperarm_l_M_MED_Marshmellow_DJ.ao/upperarm_twist_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/index_metacarpal_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/index_metacarpal_r_M_MED_Marshmellow_DJ.ao/index_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/index_metacarpal_r_M_MED_Marshmellow_DJ.ao/index_01_r_M_MED_Marshmellow_DJ.ao/index_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/index_metacarpal_r_M_MED_Marshmellow_DJ.ao/index_01_r_M_MED_Marshmellow_DJ.ao/index_02_r_M_MED_Marshmellow_DJ.ao/index_03_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/middle_metacarpal_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/middle_metacarpal_r_M_MED_Marshmellow_DJ.ao/middle_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/middle_metacarpal_r_M_MED_Marshmellow_DJ.ao/middle_01_r_M_MED_Marshmellow_DJ.ao/middle_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/middle_metacarpal_r_M_MED_Marshmellow_DJ.ao/middle_01_r_M_MED_Marshmellow_DJ.ao/middle_02_r_M_MED_Marshmellow_DJ.ao/middle_03_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_r_M_MED_Marshmellow_DJ.ao/pinky_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_r_M_MED_Marshmellow_DJ.ao/pinky_01_r_M_MED_Marshmellow_DJ.ao/pinky_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/pinky_metacarpal_r_M_MED_Marshmellow_DJ.ao/pinky_01_r_M_MED_Marshmellow_DJ.ao/pinky_02_r_M_MED_Marshmellow_DJ.ao/pinky_03_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/ring_metacarpal_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/ring_metacarpal_r_M_MED_Marshmellow_DJ.ao/ring_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/ring_metacarpal_r_M_MED_Marshmellow_DJ.ao/ring_01_r_M_MED_Marshmellow_DJ.ao/ring_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/ring_metacarpal_r_M_MED_Marshmellow_DJ.ao/ring_01_r_M_MED_Marshmellow_DJ.ao/ring_02_r_M_MED_Marshmellow_DJ.ao/ring_03_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/thumb_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/thumb_01_r_M_MED_Marshmellow_DJ.ao/thumb_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/hand_r_M_MED_Marshmellow_DJ.ao/thumb_01_r_M_MED_Marshmellow_DJ.ao/thumb_02_r_M_MED_Marshmellow_DJ.ao/thumb_03_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_twist_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_r_M_MED_Marshmellow_DJ.ao/lowerarm_twist_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/upperarm_twist_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/clavicle_r_M_MED_Marshmellow_DJ.ao/upperarm_r_M_MED_Marshmellow_DJ.ao/upperarm_twist_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/neck_01_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/spine_05_M_MED_Marshmellow_DJ.ao/neck_01_M_MED_Marshmellow_DJ.ao/neck_02_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/lowClip_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/spine_01_M_MED_Marshmellow_DJ.ao/spine_02_M_MED_Marshmellow_DJ.ao/spine_03_M_MED_Marshmellow_DJ.ao/spine_04_M_MED_Marshmellow_DJ.ao/topClip_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_l_M_MED_Marshmellow_DJ.ao/calf_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_l_M_MED_Marshmellow_DJ.ao/calf_l_M_MED_Marshmellow_DJ.ao/calf_twist_02_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_l_M_MED_Marshmellow_DJ.ao/calf_l_M_MED_Marshmellow_DJ.ao/foot_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_l_M_MED_Marshmellow_DJ.ao/calf_l_M_MED_Marshmellow_DJ.ao/foot_l_M_MED_Marshmellow_DJ.ao/ball_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_l_M_MED_Marshmellow_DJ.ao/thigh_twist_01_l_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_r_M_MED_Marshmellow_DJ.ao/calf_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_r_M_MED_Marshmellow_DJ.ao/calf_r_M_MED_Marshmellow_DJ.ao/calf_twist_02_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_r_M_MED_Marshmellow_DJ.ao/calf_r_M_MED_Marshmellow_DJ.ao/foot_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_r_M_MED_Marshmellow_DJ.ao/calf_r_M_MED_Marshmellow_DJ.ao/foot_r_M_MED_Marshmellow_DJ.ao/ball_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/thigh_r_M_MED_Marshmellow_DJ.ao/thigh_twist_01_r_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/dyn_Grenade_Front_M_MED_Marshmellow_DJ.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmellow_DJ.ao/M_MED_Marshmellow_DJ.ao_rootJoint/root_M_MED_Marshmellow_DJ.ao/pelvis_M_MED_Marshmellow_DJ.ao/dyn_Grenade_Back_M_MED_Marshmellow_DJ.ao"],[[[7,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],[7,0,0,-1,0,-0.03581999987363815,0.9993600249290466,0,0,0.9993600249290466,0.03581999987363815,0,0,-93.03402709960938,-4.042490005493164,-0.000009999999747378752,1],[7,0,0,-1,0,0.032249998301267624,0.9994800090789795,0,0,0.9994800090789795,-0.032249998301267624,0,0,-99.87068176269531,2.1180100440979004,-0.000009999999747378752,1],[7,0,0,-1,0,0.07968000322580338,0.9968199729919434,0,0,0.9968199729919434,-0.07968000322580338,0,0,-106.902587890625,7.168630123138428,-0.000009999999747378752,1],[7,0,0,-1,0,0.10931000113487244,0.9940099716186523,0,0,0.9940099716186523,-0.10931000113487244,0,0,-112.64974975585938,10.525250434875488,-0.000009999999747378752,1],[7,0,0,-1,0,0.08312000334262848,0.9965400099754333,0,0,0.9965400099754333,-0.08312000334262848,0,0,-120.98722839355469,7.344480037689209,-0.000009999999747378752,1],[7,0,0,-1,0,0.08014000207185745,0.9967799782752991,0,0,0.9967799782752991,-0.08014000207185745,0,0,-131.02322387695312,6.952459812164307,-0.000009999999747378752,1],[7,0.9964799880981445,-0.05037999898195267,0.06700000166893005,0,0.05025999993085861,0.9987300038337708,0.003379999892786145,0,-0.0670899972319603,0,0.9977499842643738,0,6.571030139923096,-3.9424901008605957,-135.35479736328125,1],[7,0.3621099889278412,-0.005049999803304672,0.9321200251579285,0,0.04125000163912773,0.9990900158882141,-0.010610000230371952,0,-0.9312199950218201,0.04228999838232994,0.3619900047779083,0,118.56501770019531,-10.436670303344727,-65.19043731689453,1],[7,0.2851499915122986,0.2339099943637848,0.9294999837875366,0,-0.43724000453948975,0.8947299718856812,-0.09102000296115875,0,-0.852940022945404,-0.3804599940776825,0.3574100136756897,0,88.2865219116211,29.976459503173828,-64.1384506225586,1],[7,0.09920000284910202,-0.9733499884605408,0.20675000548362732,0,-0.3501499891281128,0.16033999621868134,0.9228699803352356,0,-0.9314299821853638,-0.16393999755382538,-0.3249100148677826,0,79.66517639160156,48.363380432128906,25.971309661865234,1],[7,0.12723000347614288,-0.9623799920082092,0.24007000029087067,0,-0.3786500096321106,0.17657999694347382,0.9085400104522705,0,-0.9167600274085999,-0.20649999380111694,-0.34193000197410583,0,75.55220031738281,51.961429595947266,29.24897003173828,1],[7,-0.029920000582933426,-0.9734799861907959,0.22682000696659088,0,-0.25102999806404114,0.22696000337600708,0.9409899711608887,0,-0.967519998550415,-0.028780000284314156,-0.25115999579429626,0,78.16790008544922,38.25522994995117,22.61288070678711,1],[7,-0.6172099709510803,-0.7539499998092651,0.22495999932289124,0,-0.0565899983048439,0.32771000266075134,0.9430800080299377,0,-0.7847599983215332,0.569350004196167,-0.24492999911308289,0,82.50621032714844,-15.744729995727539,22.16097068786621,1],[7,-0.906440019607544,-0.35120001435279846,0.2345699965953827,0,0.12490999698638916,0.30761000514030457,0.9432799816131592,0,-0.403439998626709,0.8843200206756592,-0.23496000468730927,0,61.9079704284668,-53.457069396972656,21.107460021972656,1],[7,0.16990000009536743,-0.9619899988174438,0.21379999816417694,0,-0.32912999391555786,0.14911000430583954,0.9324399828910828,0,-0.9288700222969055,-0.22879000008106232,-0.2912899851799011,0,74.97604370117188,53.5023193359375,23.39834976196289,1],[7,0.0038300000596791506,-0.9850299954414368,0.17235000431537628,0,-0.2943100035190582,0.16360999643802643,0.9416000247001648,0,-0.9556999802589417,-0.054329998791217804,-0.2892700135707855,0,75.87377166748047,39.89004135131836,24.729089736938477,1],[7,-0.644760012626648,-0.744700014591217,0.17235000431537628,0,-0.11417999863624573,0.3167800009250641,0.9416000247001648,0,-0.755810022354126,0.5874300003051758,-0.2892700135707855,0,80.41911315917969,-17.138090133666992,24.7260799407959,1],[7,-0.8576700091362,-0.48445001244544983,0.17235000431537628,0,-0.0009800000116229057,0.33671998977661133,0.9416000247001648,0,-0.5141900181770325,0.807420015335083,-0.2892700135707855,0,67.55236053466797,-42.20240020751953,24.721250534057617,1],[7,0.2585799992084503,-0.9607800245285034,0.10018999874591827,0,-0.2088800072669983,0.045660000294446945,0.9768700003623962,0,-0.9431399703025818,-0.27351999282836914,-0.18887999653816223,0,73.71977233886719,56.437538146972656,14.321290016174316,1],[7,-0.1895499974489212,-0.981410026550293,-0.030230000615119934,0,-0.20329000055789948,0.009109999984502792,0.9790800213813782,0,-0.9606000185012817,0.19172999262809753,-0.2012300044298172,0,83.7068862915039,18.987619400024414,20.01304054260254,1],[7,-0.6956999897956848,-0.7179800271987915,-0.022619999945163727,0,-0.16102999448776245,0.12519000470638275,0.9789800047874451,0,-0.7000499963760376,0.6847100257873535,-0.20271000266075134,0,78.223876953125,-28.14936065673828,19.968969345092773,1],[7,-0.8722400069236755,-0.4890199899673462,-0.007290000095963478,0,-0.09950000047683716,0.16283999383449554,0.9816200137138367,0,-0.47885000705718994,0.856939971446991,-0.1906999945640564,0,65.17829132080078,-48.744300842285156,18.559070587158203,1],[7,0.21286000311374664,-0.968559980392456,0.1287499964237213,0,-0.22392000257968903,0.07991000264883041,0.9713299870491028,0,-0.9510800242424011,-0.23557999730110168,-0.1998700052499771,0,75.74308776855469,53.879669189453125,16.410009384155273,1],[7,-0.16839000582695007,-0.9851899743080139,0.032430000603199005,0,-0.2440900057554245,0.07355000078678131,0.9669600129127502,0,-0.955020010471344,0.15490999817848206,-0.25286000967025757,0,82.21189880371094,22.09649085998535,24.190710067749023,1],[7,-0.6725900173187256,-0.739300012588501,0.032430000603199005,0,-0.166020005941391,0.19346000254154205,0.9669600129127502,0,-0.7211499810218811,0.6449800133705139,-0.25286000967025757,0,78.36917114257812,-23.331790924072266,24.29340934753418,1],[7,-0.8281499743461609,-0.5595700144767761,0.032430000603199005,0,-0.11563999950885773,0.2272000014781952,0.9669600129127502,0,-0.5484499931335449,0.797029972076416,-0.25286000967025757,0,68.32344818115234,-40.49660873413086,24.27349090576172,1],[7,-0.6194700002670288,0.09651999920606613,0.7790600061416626,0,-0.5281500220298767,0.6829699873924255,-0.504580020904541,0,-0.580780029296875,-0.7240399718284607,-0.3721100091934204,0,69.40193176269531,66.47859191894531,4.4444899559021,1],[7,-0.4239799976348877,0.4162299931049347,0.8043599724769592,0,-0.06466999650001526,0.8719599843025208,-0.485289990901947,0,-0.9033600091934204,-0.25777000188827515,-0.3427799940109253,0,90.1048812866211,18.451940536499023,1.3043500185012817,1],[7,-0.43893998861312866,0.4406299889087677,0.783050000667572,0,-0.040449999272823334,0.8609200119972229,-0.5071300268173218,0,-0.897599995136261,-0.2542699873447418,-0.36006999015808105,0,88.0619125366211,17.7219295501709,3.2441298961639404,1],[7,0.2851499915122986,0.2339099943637848,0.9294999837875366,0,-0.43724000453948975,0.8947299718856812,-0.09102000296115875,0,-0.852940022945404,-0.3804599940776825,0.3574100136756897,0,70.431640625,29.97648048400879,-64.13845825195312,1],[7,0.2851499915122986,0.2339099943637848,0.9294999837875366,0,-0.43724000453948975,0.8947299718856812,-0.09102000296115875,0,-0.852940022945404,-0.3804599940776825,0.3574100136756897,0,78.66661834716797,29.976490020751953,-64.1384506225586,1],[7,0.3621099889278412,-0.005049999803304672,0.9321200251579285,0,0.04125000163912773,0.9990900158882141,-0.010610000230371952,0,-0.9312199950218201,0.04228999838232994,0.3619900047779083,0,118.5609130859375,-10.436670303344727,-65.19043731689453,1],[7,0.3621099889278412,-0.005049999803304672,0.9321200251579285,0,0.04125000163912773,0.9990900158882141,-0.010610000230371952,0,-0.9312199950218201,0.04228999838232994,0.3619900047779083,0,104.77091979980469,-10.436650276184082,-65.1904525756836,1],[7,0.9964699745178223,-0.05037999898195267,0.06701000034809113,0,-0.05025999993085861,-0.9987300038337708,-0.003379999892786145,0,0.06707999855279922,0,-0.9977399706840515,0,-6.570380210876465,3.9426000118255615,135.3542022705078,1],[7,0.3620299994945526,-0.005049999803304672,0.9321399927139282,0,-0.04125000163912773,-0.9990900158882141,0.010610000230371952,0,0.9312400221824646,-0.04228999838232994,-0.36191999912261963,0,-118.56948852539062,10.436710357666016,65.18167877197266,1],[7,0.2851499915122986,0.23389999568462372,0.9294899702072144,0,0.43724000453948975,-0.8947299718856812,0.09102000296115875,0,0.8529300093650818,0.3804500102996826,-0.3574199974536896,0,-88.28594970703125,-29.97599983215332,64.13921356201172,1],[7,0.09920000284910202,-0.9733399748802185,0.20675000548362732,0,0.3501499891281128,-0.16033999621868134,-0.9228699803352356,0,0.9314200282096863,0.16394999623298645,0.3249000012874603,0,-79.66471099853516,-48.36431884765625,-25.970739364624023,1],[7,0.12723000347614288,-0.962369978427887,0.24007000029087067,0,0.37863999605178833,-0.17657999694347382,-0.9085400104522705,0,0.9167500138282776,0.2065100073814392,0.34191998839378357,0,-75.55191040039062,-51.96220016479492,-29.248180389404297,1],[7,-0.029920000582933426,-0.9734699726104736,0.22682000696659088,0,0.25102999806404114,-0.22697000205516815,-0.9409899711608887,0,0.9675099849700928,0.02879999950528145,0.2511500120162964,0,-78.16767120361328,-38.255950927734375,-22.61237907409668,1],[7,-0.6172099709510803,-0.7539399862289429,0.22495999932289124,0,0.0565899983048439,-0.3277199864387512,-0.9430800080299377,0,0.7847599983215332,-0.5693399906158447,0.24492999911308289,0,-82.50614166259766,15.744440078735352,-22.16105079650879,1],[7,-0.9066200256347656,-0.351610004901886,0.23322999477386475,0,-0.12417999655008316,-0.3059299886226654,-0.9439200162887573,0,0.4032599925994873,-0.8847399950027466,0.23368999361991882,0,-61.891448974609375,53.49454116821289,-21.060089111328125,1],[7,0.16990000009536743,-0.9619799852371216,0.21379999816417694,0,0.32912999391555786,-0.14911000430583954,-0.9324399828910828,0,0.9288700222969055,0.2287999987602234,0.29128000140190125,0,-74.9754867553711,-53.50313186645508,-23.39767074584961,1],[7,0.0038300000596791506,-0.9850199818611145,0.17235000431537628,0,0.29429998993873596,-0.16360999643802643,-0.9416000247001648,0,0.9556999802589417,0.054349999874830246,0.28925999999046326,0,-75.87359619140625,-39.89086151123047,-24.728479385375977,1],[7,-0.6399499773979187,-0.7536900043487549,0.1496099978685379,0,0.08234000205993652,-0.2608399987220764,-0.9618600010871887,0,0.7639899849891663,-0.6032199859619141,0.22898000478744507,0,-81.2082290649414,18.48505973815918,-20.926050186157227,1],[7,-0.8496099710464478,-0.4925599992275238,0.18848000466823578,0,-0.048510000109672546,-0.2828899919986725,-0.9579300284385681,0,0.5251700282096863,-0.8230100274085999,0.21645000576972961,0,-68.58946228027344,43.62284851074219,-18.51412010192871,1],[7,0.25856998562812805,-0.9607700109481812,0.10018999874591827,0,0.2088800072669983,-0.045660000294446945,-0.9768700003623962,0,0.9431300163269043,0.2735399901866913,0.18887999653816223,0,-73.7190170288086,-56.438411712646484,-14.32079029083252,1],[7,-0.1895499974489212,-0.9813899993896484,-0.030230000615119934,0,0.20329000055789948,-0.009109999984502792,-0.9790800213813782,0,0.9605900049209595,-0.1917099952697754,0.2012300044298172,0,-83.70671844482422,-18.988330841064453,-20.01297950744629,1],[7,-0.6956999897956848,-0.7179700136184692,-0.022619999945163727,0,0.16102999448776245,-0.12520000338554382,-0.9789800047874451,0,0.7000499963760376,-0.6847000122070312,0.20271000266075134,0,-78.22380828857422,28.149429321289062,-19.9689998626709,1],[7,-0.8722400069236755,-0.48899999260902405,-0.007290000095963478,0,0.09950000047683716,-0.1628500074148178,-0.9816200137138367,0,0.4788399934768677,-0.8569300174713135,0.1906999945640564,0,-65.17814636230469,48.744361877441406,-18.559310913085938,1],[7,0.21285000443458557,-0.9685500264167786,0.1287499964237213,0,0.22392000257968903,-0.07991000264883041,-0.9713299870491028,0,0.9510700106620789,0.23559999465942383,0.1998700052499771,0,-75.74259185791016,-53.88045883178711,-16.40951919555664,1],[7,-0.16839000582695007,-0.9851800203323364,0.032430000603199005,0,0.2440900057554245,-0.07355999946594238,-0.9669600129127502,0,0.955020010471344,-0.1548900008201599,0.25286000967025757,0,-82.21153259277344,-22.097299575805664,-24.190519332885742,1],[7,-0.6725900173187256,-0.7392899990081787,0.032430000603199005,0,0.166020005941391,-0.19347000122070312,-0.9669600129127502,0,0.7211499810218811,-0.6449800133705139,0.25286000967025757,0,-78.36929321289062,23.331619262695312,-24.293479919433594,1],[7,-0.8281499743461609,-0.5595499873161316,0.032430000603199005,0,0.11563999950885773,-0.2272000014781952,-0.9669600129127502,0,0.5484499931335449,-0.797029972076416,0.25286000967025757,0,-68.32340240478516,40.496578216552734,-24.273719787597656,1],[7,-0.6194700002670288,0.09651000052690506,0.7790600061416626,0,0.5281599760055542,-0.6829800009727478,0.5045700073242188,0,0.580780029296875,0.7240300178527832,0.37209999561309814,0,-69.4018783569336,-66.4783935546875,-4.44419002532959,1],[7,-0.4239799976348877,0.41620999574661255,0.8043500185012817,0,0.06466999650001526,-0.8719599843025208,0.485289990901947,0,0.9033600091934204,0.25777000188827515,0.3427700102329254,0,-90.1048812866211,-18.451589584350586,-1.3039799928665161,1],[7,-0.43893998861312866,0.4406200051307678,0.783050000667572,0,0.040449999272823334,-0.8609300255775452,0.5071200132369995,0,0.897599995136261,0.25426000356674194,0.36006999015808105,0,-88.06192016601562,-17.721569061279297,-3.2437500953674316,1],[7,0.2851499915122986,0.23389999568462372,0.9294899702072144,0,0.43724000453948975,-0.8947299718856812,0.09102000296115875,0,0.8529300093650818,0.3804500102996826,-0.3574199974536896,0,-70.43112182617188,-29.976179122924805,64.13902282714844,1],[7,0.2851499915122986,0.23389999568462372,0.9294899702072144,0,0.43724000453948975,-0.8947299718856812,0.09102000296115875,0,0.8529300093650818,0.3804500102996826,-0.3574199974536896,0,-78.66609954833984,-29.97610092163086,64.13910675048828,1],[7,0.3620699942111969,-0.005049999803304672,0.9321200251579285,0,-0.04125000163912773,-0.9990900158882141,0.010610000230371952,0,0.9312199950218201,-0.04230000078678131,-0.3619700074195862,0,-118.56214904785156,10.436779975891113,65.18757629394531,1],[7,0.3620699942111969,-0.005049999803304672,0.9321200251579285,0,-0.04125000163912773,-0.9990900158882141,0.010610000230371952,0,0.9312199950218201,-0.04230000078678131,-0.3619700074195862,0,-104.7722396850586,10.43677043914795,65.18789672851562,1],[7,0,0,-1,0,-0.3174700140953064,0.9482700228691101,0,0,0.9482700228691101,0.3174700140953064,0,0,-133.70706176757812,-49.322898864746094,-0.000009999999747378752,1],[7,0,0,-1,0,-0.22033999860286713,0.9754199981689453,0,0,0.9754199981689453,0.22033999860286713,0,0,-142.53468322753906,-35.1444206237793,-0.000009999999747378752,1],[7,0.9283699989318848,-0.09962999820709229,-0.35804998874664307,0,0.10583999752998352,0.994379997253418,-0.0022700000554323196,0,0.3562600016593933,-0.03579000011086464,0.9337000250816345,0,-45.227569580078125,17.154239654541016,-114.65667724609375,1],[7,-0.4154199957847595,-0.18039000034332275,-0.8915600180625916,0,0.12738999724388123,0.9589400291442871,-0.2533800005912781,0,0.90065997838974,-0.21883000433444977,-0.3753899931907654,0,-109.90592193603516,39.67750930786133,52.29949188232422,1],[7,-0.11416000127792358,-0.000699999975040555,-0.9934599995613098,0,-0.004860000219196081,0.9999899864196777,-0.0001500000071246177,0,0.9934499859809875,0.004809999838471413,-0.11416000127792358,0,-89.07008361816406,-1.2403700351715088,18.037109375,1],[7,-0.0817599967122078,-0.009639999829232693,-0.9966099858283997,0,-0.08285000175237656,0.9965599775314331,-0.002839999971911311,0,0.9932000041007996,0.08234000205993652,-0.08226999640464783,0,-50.32640075683594,-5.140620231628418,16.427709579467773,1],[7,-0.10050000250339508,-0.057500001043081284,-0.9932699799537659,0,-0.09036999940872192,0.9947299957275391,-0.04843999817967415,0,0.9908199906349182,0.08489000052213669,-0.10516999661922455,0,-31.164470672607422,-4.660920143127441,17.220909118652344,1],[7,0.00570000009611249,-0.09048999845981598,-0.9958800077438354,0,-0.010119999758899212,0.9958400130271912,-0.09053999930620193,0,0.9999300241470337,0.010590000078082085,0.0047599999234080315,0,-9.484869956970215,-3.1183300018310547,15.553030014038086,1],[7,0.09066999703645706,0.005489999894052744,-0.9958699941635132,0,-0.9958500266075134,-0.007790000177919865,-0.09070999920368195,0,-0.008259999565780163,0.9999499917030334,0.0047599999234080315,0,-10.718350410461426,-3.299999952316284,14.870599746704102,1],[7,-0.11416000127792358,-0.003220000071451068,-0.9934599995613098,0,-0.004860000219196081,0.9999799728393555,-0.00267999991774559,0,0.9934499859809875,0.004519999958574772,-0.11416999995708466,0,-67.4397964477539,-1.1946099996566772,18.040210723876953,1],[7,-0.11469999700784683,-0.000699999975040555,-0.993399977684021,0,0.004860000219196081,-0.9999899864196777,0.0001500000071246177,0,-0.9935500025749207,-0.004809999838471413,0.11467999964952469,0,89.07520294189453,1.2399300336837769,-18.083269119262695,1],[7,-0.08178000152111053,-0.009639999829232693,-0.9966099858283997,0,0.0828699991106987,-0.9965599775314331,0.002839999971911311,0,-0.9933599829673767,-0.08235999941825867,0.08226999640464783,0,50.334259033203125,5.141630172729492,-16.427419662475586,1],[7,-0.1005299985408783,-0.057509999722242355,-0.9932699799537659,0,0.090379998087883,-0.9947299957275391,0.04843999817967415,0,-0.9909800291061401,-0.0849199965596199,0.10516999661922455,0,31.16922950744629,4.661630153656006,-17.220869064331055,1],[7,0.005679999943822622,-0.09048999845981598,-0.9958800077438354,0,0.010119999758899212,-0.9958400130271912,0.09053999930620193,0,-1.0000900030136108,-0.010590000078082085,-0.0047900001518428326,0,9.485939979553223,3.1183600425720215,-15.55282974243164,1],[7,0.09066999703645706,0.005439999978989363,-0.9958699941635132,0,0.9958500266075134,0.007799999788403511,0.09070999920368195,0,0.008259999565780163,-1.0001100301742554,-0.0047599999234080315,0,10.718339920043945,3.2996699810028076,-14.87067985534668,1],[7,-0.11462000012397766,-0.003220000071451068,-0.9934099912643433,0,0.004860000219196081,-0.9999799728393555,0.00267999991774559,0,-0.9935600161552429,-0.004519999958574772,0.11460000276565552,0,67.44293212890625,1.194290041923523,-18.069459915161133,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,-15.137189865112305,-5.633389949798584,-96.44197845458984,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,-7.095640182495117,-14.249750137329102,-96.61615753173828,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[16,".bin",1718542797,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":529776,"length":29568,"count":7392,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":529776,"count":7358,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,3,4,5,6,7,8,33,35,62,64,65,78,79]]},"minPosition",8,[1,-16.84214973449707,-17.83820915222168,84.19788360595703],"maxPosition",8,[1,25.046829223632812,22.40226936340332,145.19985961914062]]],-1],0,0,[],[],[]],[[[16,".bin",717072845,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":517600,"length":26616,"count":6654,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":517600,"count":6470,"stride":80},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,7,8,9,10,11,13]]},"minPosition",8,[1,-15.298600196838379,-13.183300018310547,139.2225799560547],"maxPosition",8,[1,15.298600196838379,17.585790634155273,172.0599822998047]]],-1],0,0,[],[],[]],[[[18,"Skin-1",2923016472,["RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/attach_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao/clavicle_l_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao/clavicle_r_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao/neck_01_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao/neck_01_M_MED_Marshmallow_DJ_FaceAcc.ao/neck_02_M_MED_Marshmallow_DJ_FaceAcc.ao","RootNode (gltf orientation matrix)/RootNode (model correction matrix)/Root/M_MED_Marshmallow_DJ_FaceAcc.ao/M_MED_Marshmallow_DJ_FaceAcc.ao_rootJoint/root_M_MED_Marshmallow_DJ_FaceAcc.ao/pelvis_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_01_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_02_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_03_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_04_M_MED_Marshmallow_DJ_FaceAcc.ao/spine_05_M_MED_Marshmallow_DJ_FaceAcc.ao/neck_01_M_MED_Marshmallow_DJ_FaceAcc.ao/neck_02_M_MED_Marshmallow_DJ_FaceAcc.ao/head_M_MED_Marshmallow_DJ_FaceAcc.ao"],[[[7,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],[7,0,0,-1,0,-0.03581999987363815,0.9993600249290466,0,0,0.9993600249290466,0.03581999987363815,0,0,-93.03402709960938,-4.042490005493164,-0.000009999999747378752,1],[7,0,0,-1,0,0.032249998301267624,0.9994800090789795,0,0,0.9994800090789795,-0.032249998301267624,0,0,-99.87068176269531,2.1180100440979004,-0.000009999999747378752,1],[7,0,0,-1,0,0.07968000322580338,0.9968199729919434,0,0,0.9968199729919434,-0.07968000322580338,0,0,-106.902587890625,7.168630123138428,-0.000009999999747378752,1],[7,0,0,-1,0,0.10931000113487244,0.9940099716186523,0,0,0.9940099716186523,-0.10931000113487244,0,0,-112.64974975585938,10.525250434875488,-0.000009999999747378752,1],[7,0,0,-1,0,0.08312000334262848,0.9965400099754333,0,0,0.9965400099754333,-0.08312000334262848,0,0,-120.98722839355469,7.344480037689209,-0.000009999999747378752,1],[7,0,0,-1,0,0.08014000207185745,0.9967799782752991,0,0,0.9967799782752991,-0.08014000207185745,0,0,-131.02322387695312,6.952459812164307,-0.000009999999747378752,1],[7,0.9964799880981445,-0.05037999898195267,0.06700000166893005,0,0.05025999993085861,0.9987300038337708,0.003379999892786145,0,-0.0670899972319603,0,0.9977499842643738,0,6.571020126342773,-3.9424901008605957,-135.3547821044922,1],[7,0.9964699745178223,-0.05037999898195267,0.06701000034809113,0,-0.05025999993085861,-0.9987300038337708,-0.003379999892786145,0,0.06707999855279922,0,-0.9977399706840515,0,-6.570380210876465,3.9426000118255615,135.3542022705078,1],[7,0,0,-1,0,-0.3174700140953064,0.9482700228691101,0,0,0.9482700228691101,0.3174700140953064,0,0,-133.70706176757812,-49.322898864746094,-0.000009999999747378752,1],[7,0,0,-1,0,-0.22033999860286713,0.9754199981689453,0,0,0.9754199981689453,0.22033999860286713,0,0,-142.53468322753906,-35.1444206237793,-0.000009999999747378752,1],[7,0,0,-1,0,0.008270000107586384,0.999970018863678,0,0,0.999970018863678,-0.008270000107586384,0,0,-152.04298400878906,-0.43007001280784607,-0.000009999999747378752,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[5,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[2,1]],[[[5,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[2,3],[7,1]]]]
